From 42e2b02ba3daeed0043256a3bd4f21051befc19e Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Fri, 12 Jun 2020 17:02:11 +0200
Subject: [PATCH 01/24] Initial attempt to build Wii port of SDL with official
 tools

---
 src/audio/SDL_audio.c              |   3 +
 src/audio/SDL_sysaudio.h           |   3 +
 src/audio/wii/SDL_wiiaudio.c       | 249 +++++++++
 src/audio/wii/SDL_wiiaudio.h       |  40 ++
 src/file/wii/SDL_wiirwops.c        | 157 ++++++
 src/joystick/wii/SDL_sysjoystick.c | 552 ++++++++++++++++++
 src/main/wii/SDL_wii_main.c        |  86 +++
 src/thread/SDL_thread_c.h          |   2 +
 src/thread/wii/SDL_syscond.c       | 139 +++++
 src/thread/wii/SDL_sysmutex.c      |  87 +++
 src/thread/wii/SDL_sysmutex_c.h    |  26 +
 src/thread/wii/SDL_syssem.c        | 175 ++++++
 src/thread/wii/SDL_systhread.c     |  80 +++
 src/thread/wii/SDL_systhread_c.h   |  26 +
 src/timer/wii/SDL_systimer.c       | 102 ++++
 src/video/SDL_sysvideo.h           |   3 +
 src/video/SDL_video.c              |   3 +
 src/video/wii/SDL_wiievents.c      | 261 +++++++++
 src/video/wii/SDL_wiievents_c.h    |  33 ++
 src/video/wii/SDL_wiimouse.c       |  33 ++
 src/video/wii/SDL_wiimouse_c.h     |  26 +
 src/video/wii/SDL_wiivideo.c       | 866 +++++++++++++++++++++++++++++
 src/video/wii/SDL_wiivideo.h       |  51 ++
 23 files changed, 3003 insertions(+)
 create mode 100644 src/audio/wii/SDL_wiiaudio.c
 create mode 100644 src/audio/wii/SDL_wiiaudio.h
 create mode 100644 src/file/wii/SDL_wiirwops.c
 create mode 100644 src/joystick/wii/SDL_sysjoystick.c
 create mode 100644 src/main/wii/SDL_wii_main.c
 create mode 100644 src/thread/wii/SDL_syscond.c
 create mode 100644 src/thread/wii/SDL_sysmutex.c
 create mode 100644 src/thread/wii/SDL_sysmutex_c.h
 create mode 100644 src/thread/wii/SDL_syssem.c
 create mode 100644 src/thread/wii/SDL_systhread.c
 create mode 100644 src/thread/wii/SDL_systhread_c.h
 create mode 100644 src/timer/wii/SDL_systimer.c
 create mode 100644 src/video/wii/SDL_wiievents.c
 create mode 100644 src/video/wii/SDL_wiievents_c.h
 create mode 100644 src/video/wii/SDL_wiimouse.c
 create mode 100644 src/video/wii/SDL_wiimouse_c.h
 create mode 100644 src/video/wii/SDL_wiivideo.c
 create mode 100644 src/video/wii/SDL_wiivideo.h

diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index beb26e0b4..4e8d3d542 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -112,6 +112,9 @@ static AudioBootStrap *bootstrap[] = {
 #endif
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 	&EPOCAudio_bootstrap,
+#endif
+#if SDL_AUDIO_DRIVER_WII
+	&WIIAUD_bootstrap,
 #endif
 	NULL
 };
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 74ac21df0..5ee8e6b2f 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -179,6 +179,9 @@ extern AudioBootStrap DART_bootstrap;
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 extern AudioBootStrap EPOCAudio_bootstrap; 
 #endif
+#if SDL_AUDIO_DRIVER_WII
+extern AudioBootStrap WIIAUD_bootstrap;
+#endif
 
 /* This is the current audio device */
 extern SDL_AudioDevice *current_audio;
diff --git a/src/audio/wii/SDL_wiiaudio.c b/src/audio/wii/SDL_wiiaudio.c
new file mode 100644
index 000000000..b97cfd11a
--- /dev/null
+++ b/src/audio/wii/SDL_wiiaudio.c
@@ -0,0 +1,249 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken at libsdl.or
+*/
+#include "SDL_config.h"
+
+// Public includes.
+#include "SDL_timer.h"
+
+// Audio internal includes.
+#include "SDL_audio.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_sysaudio.h"
+#include "../SDL_audio_c.h"
+
+// Wii audio internal includes.
+#include <ogcsys.h>
+#include <ogc/audio.h>
+#include <ogc/cache.h>
+#include "SDL_wiiaudio.h"
+
+#define SAMPLES_PER_DMA_BUFFER (512)
+
+static const char WIIAUD_DRIVER_NAME[] = "wii";
+static Uint32 dma_buffers[2][SAMPLES_PER_DMA_BUFFER*8] __attribute__((aligned(32)));
+static int dma_buffers_size[2] = { SAMPLES_PER_DMA_BUFFER*4, SAMPLES_PER_DMA_BUFFER*4 };
+static Uint8 whichab = 0;
+
+#define AUDIOSTACK 16384*2
+static lwpq_t audioqueue;
+static lwp_t athread = LWP_THREAD_NULL;
+static Uint8 astack[AUDIOSTACK];
+static bool stopaudio = false;
+static int currentfreq;
+
+/****************************************************************************
+ * Audio Threading
+ ***************************************************************************/
+static void *
+AudioThread (void *arg)
+{
+	while (1)
+	{
+		if(stopaudio)
+			break;
+
+		memset(dma_buffers[whichab], 0, SAMPLES_PER_DMA_BUFFER*4);
+
+		// Is the device ready?
+		if (!current_audio || current_audio->paused)
+		{
+			DCFlushRange(dma_buffers[whichab], SAMPLES_PER_DMA_BUFFER*4);
+			dma_buffers_size[whichab] = SAMPLES_PER_DMA_BUFFER*4;
+		}
+		else if (current_audio->convert.needed) // Is conversion required?
+		{
+			SDL_mutexP(current_audio->mixer_lock);
+			// Get the client to produce audio
+			current_audio->spec.callback(
+				current_audio->spec.userdata,
+				current_audio->convert.buf,
+				current_audio->convert.len);
+			SDL_mutexV(current_audio->mixer_lock);
+
+			// Convert the audio
+			SDL_ConvertAudio(&current_audio->convert);
+
+			// Copy from SDL buffer to DMA buffer
+			memcpy(dma_buffers[whichab], current_audio->convert.buf, current_audio->convert.len_cvt);
+			DCFlushRange(dma_buffers[whichab], current_audio->convert.len_cvt);
+			dma_buffers_size[whichab] = current_audio->convert.len_cvt;
+		}
+		else
+		{
+			SDL_mutexP(current_audio->mixer_lock);
+			current_audio->spec.callback(
+				current_audio->spec.userdata,
+				(Uint8 *)dma_buffers[whichab],
+				SAMPLES_PER_DMA_BUFFER*4);
+			DCFlushRange(dma_buffers[whichab], SAMPLES_PER_DMA_BUFFER*4);
+			dma_buffers_size[whichab] = SAMPLES_PER_DMA_BUFFER*4;
+			SDL_mutexV(current_audio->mixer_lock);
+		}
+		LWP_ThreadSleep (audioqueue);
+	}
+	return NULL;
+}
+
+/****************************************************************************
+ * DMACallback
+ * Playback audio and signal audio thread that more samples are required
+ ***************************************************************************/
+static void
+DMACallback()
+{
+	whichab ^= 1;
+	AUDIO_InitDMA ((Uint32)dma_buffers[whichab], dma_buffers_size[whichab]);
+	LWP_ThreadSignal (audioqueue);
+}
+
+void WII_AudioStop()
+{
+	AUDIO_StopDMA ();
+	AUDIO_RegisterDMACallback(0);
+	stopaudio = true;
+	LWP_ThreadSignal(audioqueue);
+	LWP_JoinThread(athread, NULL);
+	LWP_CloseQueue (audioqueue);
+	athread = LWP_THREAD_NULL;
+}
+
+void WII_AudioStart()
+{
+	if (currentfreq == 32000)
+		AUDIO_SetDSPSampleRate(AI_SAMPLERATE_32KHZ);
+	else
+		AUDIO_SetDSPSampleRate(AI_SAMPLERATE_48KHZ);
+
+	// startup conversion thread
+	stopaudio = false;
+	LWP_InitQueue (&audioqueue);
+	LWP_CreateThread (&athread, AudioThread, NULL, astack, AUDIOSTACK, 67);
+
+	// Start the first chunk of audio playing
+	AUDIO_RegisterDMACallback(DMACallback);
+	DMACallback();
+	AUDIO_StartDMA();
+}
+
+static int WIIAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+{
+	if (spec->freq != 32000 && spec->freq != 48000)
+		spec->freq = 32000;
+
+	// Set up actual spec.
+	spec->format	= AUDIO_S16MSB;
+	spec->channels	= 2;
+	spec->samples	= SAMPLES_PER_DMA_BUFFER;
+	spec->padding	= 0;
+	SDL_CalculateAudioSpec(spec);
+
+	memset(dma_buffers[0], 0, sizeof(dma_buffers[0]));
+	memset(dma_buffers[1], 0, sizeof(dma_buffers[0]));
+
+	currentfreq = spec->freq;
+	WII_AudioStart();
+
+	return 1;
+}
+
+void static WIIAUD_WaitAudio(_THIS)
+{
+
+}
+
+static void WIIAUD_PlayAudio(_THIS)
+{
+
+}
+
+static Uint8 *WIIAUD_GetAudioBuf(_THIS)
+{
+	return NULL;
+}
+
+static void WIIAUD_CloseAudio(_THIS)
+{
+	// Stop any DMA going on
+	AUDIO_StopDMA();
+
+	// terminate conversion thread
+	LWP_ThreadSignal(audioqueue);
+}
+
+static void WIIAUD_DeleteDevice(SDL_AudioDevice *device)
+{
+	// Forget the DMA callback
+	AUDIO_RegisterDMACallback(0);
+
+	// Stop any DMA going on
+	AUDIO_StopDMA();
+
+	// terminate conversion thread
+	LWP_ThreadSignal(audioqueue);
+
+	SDL_free(device->hidden);
+	SDL_free(device);
+}
+
+static SDL_AudioDevice *WIIAUD_CreateDevice(int devindex)
+{
+	SDL_AudioDevice *this;
+
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
+	if ( this ) {
+		SDL_memset(this, 0, (sizeof *this));
+		this->hidden = (struct SDL_PrivateAudioData *)
+				SDL_malloc((sizeof *this->hidden));
+	}
+	if ( (this == NULL) || (this->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( this ) {
+			SDL_free(this);
+		}
+		return(0);
+	}
+	SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+
+	// Initialise the Wii side of the audio system
+	AUDIO_Init(0);
+
+	/* Set the function pointers */
+	this->OpenAudio = WIIAUD_OpenAudio;
+	this->WaitAudio = WIIAUD_WaitAudio;
+	this->PlayAudio = WIIAUD_PlayAudio;
+	this->GetAudioBuf = WIIAUD_GetAudioBuf;
+	this->CloseAudio = WIIAUD_CloseAudio;
+	this->free = WIIAUD_DeleteDevice;
+
+	return this;
+}
+
+static int WIIAUD_Available(void)
+{
+	return 1;
+}
+
+AudioBootStrap WIIAUD_bootstrap = {
+	WIIAUD_DRIVER_NAME, "SDL Wii audio driver",
+	WIIAUD_Available, WIIAUD_CreateDevice
+};
diff --git a/src/audio/wii/SDL_wiiaudio.h b/src/audio/wii/SDL_wiiaudio.h
new file mode 100644
index 000000000..ef759be0d
--- /dev/null
+++ b/src/audio/wii/SDL_wiiaudio.h
@@ -0,0 +1,40 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_wiiaudio_h
+#define _SDL_wiiaudio_h
+
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData {
+	/* The file descriptor for the audio device */
+	Uint8 *mixbuf;
+	Uint32 mixlen;
+	Uint32 write_delay;
+	Uint32 initial_calls;
+};
+
+#endif /* _SDL_dummyaudio_h */
diff --git a/src/file/wii/SDL_wiirwops.c b/src/file/wii/SDL_wiirwops.c
new file mode 100644
index 000000000..471237bbc
--- /dev/null
+++ b/src/file/wii/SDL_wiirwops.c
@@ -0,0 +1,157 @@
+/*
+SDL - Simple DirectMedia Layer
+Copyright (C) 1997-2006 Sam Lantinga
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+Sam Lantinga
+slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* This file provides a general interface for SDL to read and write
+data sources.  It can easily be extended to files, memory, etc.
+*/
+
+#include "SDL_endian.h"
+#include "SDL_rwops.h"
+
+#ifdef __WII__
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <sys/stat.h>
+
+static SDL_bool initialised = SDL_FALSE;
+
+extern bool fatInitDefault(void);
+
+static int SDLCALL wii_seek(SDL_RWops *context, int offset, int whence)
+{
+	int action;
+
+	switch (whence)
+	{
+		case RW_SEEK_CUR:
+			action = SEEK_CUR;
+			break;
+		case RW_SEEK_END:
+			action = SEEK_END;
+			break;
+		case RW_SEEK_SET:
+			action = SEEK_SET;
+			break;
+		default:
+			SDL_Error(SDL_EFSEEK);
+			return(-1);
+	}
+
+	if ( fseek(context->hidden.wii.fp, offset, action) == 0 ) {
+		return ftell(context->hidden.wii.fp);
+	} else {
+		SDL_Error(SDL_EFSEEK);
+		return(-1);
+	}
+}
+
+static int SDLCALL wii_read(SDL_RWops *context, void *ptr, int size, int num)
+{
+	int bytes_read;
+	bytes_read = fread(ptr, size, num, context->hidden.wii.fp);
+	if ( bytes_read == -1) {
+		SDL_Error(SDL_EFREAD);
+		return(-1);
+	}
+	return(bytes_read);
+}
+
+static int SDLCALL wii_write(SDL_RWops *context, const void *ptr, int size, int num)
+{
+	int bytes_written;
+
+	bytes_written = fwrite(ptr, size, num, context->hidden.wii.fp);
+	if ( bytes_written != (size * num) ) {
+		SDL_Error(SDL_EFWRITE);
+		return(-1);
+	}
+	return(num);
+}
+
+static int SDLCALL wii_close(SDL_RWops *context)
+{
+	if ( context )
+	{
+		fclose(context->hidden.wii.fp);
+		SDL_FreeRW(context);
+	}
+	return(0);
+}
+
+SDL_RWops *SDL_RWFromFile(const char *file, const char *mode)
+{
+	int stat_result;
+	struct stat stat_info;
+	FILE* fp;
+
+	if (!file || !*file || !mode || !*mode)
+	{
+		SDL_SetError("SDL_RWFromFile(): No file or no mode specified");
+		return NULL;
+	}
+
+	/* Initialise the SD library */
+	if (!initialised)
+	{
+		fatInitDefault();
+		initialised = SDL_TRUE;
+	}
+
+	/* Opening for reading? */
+	memset(&stat_info, 0, sizeof(stat_info));
+	if (mode[0] == 'r')
+	{
+		/* Find the file */
+		stat_result = stat(file, &stat_info);
+		if (stat_result != 0)
+		{
+			SDL_SetError("Couldn't find %s to get its length", file);
+			return NULL;
+		}
+	}
+
+	/* Open the file */
+	fp = fopen(file, mode);
+	if ( fp == NULL )
+	{
+		SDL_SetError("Couldn't open %s", file);
+		return NULL;
+	}
+	else
+	{
+		SDL_RWops *rwops = SDL_AllocRW();
+		if ( rwops != NULL )
+		{
+			rwops->seek = wii_seek;
+			rwops->read = wii_read;
+			rwops->write = wii_write;
+			rwops->close = wii_close;
+			rwops->hidden.wii.fp = fp;
+			rwops->hidden.wii.size = stat_info.st_size;
+		}
+		return(rwops);
+	}
+}
+
+#endif /* __WII__ */
diff --git a/src/joystick/wii/SDL_sysjoystick.c b/src/joystick/wii/SDL_sysjoystick.c
new file mode 100644
index 000000000..fb7c693a4
--- /dev/null
+++ b/src/joystick/wii/SDL_sysjoystick.c
@@ -0,0 +1,552 @@
+/*
+ SDL - Simple DirectMedia Layer
+ Copyright (C) 1997-2006 Sam Lantinga
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Sam Lantinga
+ slouken@libsdl.org
+ */
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_WII
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <gccore.h>
+#include <unistd.h>
+#include <wiiuse/wpad.h>
+#include <math.h>
+
+#define PI 					3.14159265f
+
+#define MAX_GC_JOYSTICKS	4
+#define MAX_WII_JOYSTICKS	4
+#define MAX_JOYSTICKS		(MAX_GC_JOYSTICKS + MAX_WII_JOYSTICKS)
+
+#define MAX_GC_AXES			6
+#define MAX_GC_BUTTONS		8
+#define	MAX_GC_HATS			1
+
+#define MAX_WII_AXES		9
+#define MAX_WII_BUTTONS		20
+#define	MAX_WII_HATS		1
+
+#define	JOYNAMELEN			10
+
+#define AXIS_MIN	-32768  /* minimum value for axis coordinate */
+#define AXIS_MAX	32767   /* maximum value for axis coordinate */
+
+typedef struct joystick_paddata_t
+{
+	u16 prev_buttons;
+	s8 stickX;
+	s8 stickY;
+	s8 substickX;
+	s8 substickY;
+	u8 triggerL;
+	u8 triggerR;
+}joystick_paddata;
+
+typedef struct joystick_wpaddata_t
+{
+	u32 prev_buttons;
+	s8 nunchuk_stickX;
+	s8 nunchuk_stickY;
+	s8 classicL_stickX;
+	s8 classicL_stickY;
+	s8 classicR_stickX;
+	s8 classicR_stickY;
+	u8 classic_triggerL;
+	u8 classic_triggerR;
+	s8 wiimote_pitch;
+	s8 wiimote_roll;
+	s8 wiimote_yaw;
+}joystick_wpaddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata_t
+{
+	int index;
+	int type;
+	union
+	{
+		joystick_paddata gamecube;
+		joystick_wpaddata wiimote;
+	};
+} joystick_hwdata;
+
+static const u32 sdl_buttons_wii[] =
+{
+	WPAD_BUTTON_A,
+	WPAD_BUTTON_B,
+	WPAD_BUTTON_1,
+	WPAD_BUTTON_2,
+	WPAD_BUTTON_MINUS,
+	WPAD_BUTTON_PLUS,
+	WPAD_BUTTON_HOME,
+	WPAD_NUNCHUK_BUTTON_Z, /* 7 */
+	WPAD_NUNCHUK_BUTTON_C, /* 8 */
+	WPAD_CLASSIC_BUTTON_A, /* 9 */
+	WPAD_CLASSIC_BUTTON_B,
+	WPAD_CLASSIC_BUTTON_X,
+	WPAD_CLASSIC_BUTTON_Y,
+	WPAD_CLASSIC_BUTTON_FULL_L,
+	WPAD_CLASSIC_BUTTON_FULL_R,
+	WPAD_CLASSIC_BUTTON_ZL,
+	WPAD_CLASSIC_BUTTON_ZR,
+	WPAD_CLASSIC_BUTTON_MINUS,
+	WPAD_CLASSIC_BUTTON_PLUS,
+	WPAD_CLASSIC_BUTTON_HOME
+};
+
+static const u16 sdl_buttons_gc[] =
+{
+	PAD_BUTTON_A,
+	PAD_BUTTON_B,
+	PAD_BUTTON_X,
+	PAD_BUTTON_Y,
+	PAD_TRIGGER_Z,
+	PAD_TRIGGER_R,
+	PAD_TRIGGER_L,
+	PAD_BUTTON_START
+};
+
+static int __jswpad_enabled = 1;
+static int __jspad_enabled = 1;
+static int __numwiijoysticks = 4;
+static int __numgcjoysticks = 4;
+
+/* Helpers to separate nunchuk vs classic buttons which share the
+ * same scan codes. In particular, up on the classic controller is
+ * the same as Z on the nunchuk. The numbers refer to the sdl_buttons_wii
+ * list above. */
+static int wii_button_is_nunchuk(int idx)
+{
+	return idx == 7 || idx == 8;
+}
+
+static int wii_button_is_classic(int idx)
+{
+	return idx >= 9;
+}
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	return 8;
+}
+
+static char joy_name[] = "Gamecube 0";
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	if((index < 4) && (__jswpad_enabled) && (index < __numwiijoysticks))
+	sprintf(joy_name, "Wiimote %d", index);
+	else if((index < 8) && (__jspad_enabled) && (index < (__numgcjoysticks + 4)) && (index> 3))
+	sprintf(joy_name, "Gamecube %d", index);
+	return (const char *)joy_name;
+}
+
+/* Function to open a joystick for use.
+ The joystick to open is specified by the index field of the joystick.
+ This should fill the nbuttons and naxes fields of the joystick structure.
+ It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	/* allocate memory for system specific hardware data */
+	joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+	if (joystick->hwdata == NULL)
+	{
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+	if((joystick->index < 4) && (__jswpad_enabled))
+	{
+		if(joystick->index < __numwiijoysticks)
+		{
+			((joystick_hwdata*)(joystick->hwdata))->index = joystick->index;
+			((joystick_hwdata*)(joystick->hwdata))->type = 0;
+			joystick->nbuttons = MAX_WII_BUTTONS;
+			joystick->naxes = MAX_WII_AXES;
+			joystick->nhats = MAX_WII_HATS;
+		}
+	}
+	else if((joystick->index < 8) && (__jspad_enabled))
+	{
+		if(joystick->index < (__numgcjoysticks + 4))
+		{
+			((joystick_hwdata*)(joystick->hwdata))->index = joystick->index - 4;
+			((joystick_hwdata*)(joystick->hwdata))->type = 1;
+			joystick->nbuttons = MAX_GC_BUTTONS;
+			joystick->naxes = MAX_GC_AXES;
+			joystick->nhats = MAX_GC_HATS;
+		}
+	}
+	return(0);
+}
+
+static s16 WPAD_Orient(WPADData *data, int motion)
+{
+	float out;
+
+	if (motion == 0)
+		out = data->orient.pitch;
+	else if (motion == 1)
+		out = data->orient.roll;
+	else
+		out = data->orient.yaw;
+
+	return (s16)((out / 180.0) * 128.0);
+}
+
+static s16 WPAD_Pitch(WPADData *data)
+{
+	return WPAD_Orient(data, 0);
+}
+
+static s16 WPAD_Roll(WPADData *data)
+{
+	return WPAD_Orient(data, 1);
+}
+
+static s16 WPAD_Yaw(WPADData *data)
+{
+	return WPAD_Orient(data, 2);
+}
+
+static s16 WPAD_Stick(WPADData *data, u8 right, int axis)
+{
+	float mag = 0.0;
+	float ang = 0.0;
+
+	switch (data->exp.type)
+	{
+		case WPAD_EXP_NUNCHUK:
+		case WPAD_EXP_GUITARHERO3:
+			if (right == 0)
+			{
+				mag = data->exp.nunchuk.js.mag;
+				ang = data->exp.nunchuk.js.ang;
+			}
+			break;
+
+		case WPAD_EXP_CLASSIC:
+			if (right == 0)
+			{
+				mag = data->exp.classic.ljs.mag;
+				ang = data->exp.classic.ljs.ang;
+			}
+			else
+			{
+				mag = data->exp.classic.rjs.mag;
+				ang = data->exp.classic.rjs.ang;
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	/* calculate x/y value (angle need to be converted into radian) */
+	if (mag > 1.0) mag = 1.0;
+	else if (mag < -1.0) mag = -1.0;
+	double val;
+
+	if(axis == 0) // x-axis
+		val = mag * sin((PI * ang)/180.0f);
+	else // y-axis
+		val = mag * cos((PI * ang)/180.0f);
+
+	return (s16)(val * 128.0f);
+}
+
+static void _HandleWiiJoystickUpdate(SDL_Joystick* joystick)
+{
+	u32 buttons, prev_buttons, changed;
+	u32 exp_type;
+	struct expansion_t exp;
+	int i, axis;
+	joystick_hwdata *prev_state;
+	WPADData *data;
+
+	buttons = WPAD_ButtonsHeld(joystick->index);
+
+	if (WPAD_Probe(joystick->index, &exp_type) != 0)
+		exp_type = WPAD_EXP_NONE;
+
+	 data = WPAD_Data(joystick->index);
+	 WPAD_Expansion(joystick->index, &exp);
+
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->wiimote.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(exp_type == WPAD_EXP_CLASSIC) // classic controller
+	{
+		if(changed & (WPAD_CLASSIC_BUTTON_LEFT | WPAD_CLASSIC_BUTTON_RIGHT |
+			WPAD_CLASSIC_BUTTON_DOWN | WPAD_CLASSIC_BUTTON_UP))
+		{
+			int hat = SDL_HAT_CENTERED;
+			if(buttons & WPAD_CLASSIC_BUTTON_UP) hat |= SDL_HAT_UP;
+			if(buttons & WPAD_CLASSIC_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+			if(buttons & WPAD_CLASSIC_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+			if(buttons & WPAD_CLASSIC_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+			SDL_PrivateJoystickHat(joystick, 0, hat);
+		}
+	}
+	else // wiimote
+	{
+		if(changed & (WPAD_BUTTON_LEFT | WPAD_BUTTON_RIGHT | WPAD_BUTTON_DOWN | WPAD_BUTTON_UP))
+		{
+			int hat = SDL_HAT_CENTERED;
+			if(buttons & WPAD_BUTTON_UP) hat |= SDL_HAT_LEFT;
+			if(buttons & WPAD_BUTTON_DOWN) hat |= SDL_HAT_RIGHT;
+			if(buttons & WPAD_BUTTON_LEFT) hat |= SDL_HAT_DOWN;
+			if(buttons & WPAD_BUTTON_RIGHT) hat |= SDL_HAT_UP;
+			SDL_PrivateJoystickHat(joystick, 0, hat);
+		}
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0])); i++)
+	{
+		if ( (exp_type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+				(exp_type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i)) )
+			continue;
+
+		if (changed & sdl_buttons_wii[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_wii[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->wiimote.prev_buttons = buttons;
+
+	if(exp_type == WPAD_EXP_CLASSIC)
+	{
+		axis = WPAD_Stick(data, 0, 0);
+		if(prev_state->wiimote.classicL_stickX != axis)
+		{
+			s16 value;
+			if (axis >= 128) value = AXIS_MAX;
+			else if (axis <=-128) value = AXIS_MIN;
+			else value = axis << 8;
+			SDL_PrivateJoystickAxis(joystick, 0, value);
+			prev_state->wiimote.classicL_stickX = axis;
+		}
+		axis = WPAD_Stick(data, 0, 1);
+		if(prev_state->wiimote.classicL_stickY != axis)
+		{
+			s16 value;
+			if (axis >= 128) value = AXIS_MAX;
+			else if (axis <=-128) value = AXIS_MIN;
+			else value = axis << 8;
+			SDL_PrivateJoystickAxis(joystick, 1, -value);
+			prev_state->wiimote.classicL_stickY = axis;
+		}
+		axis = WPAD_Stick(data, 1, 0);
+		if(prev_state->wiimote.classicR_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+			prev_state->wiimote.classicR_stickX = axis;
+		}
+		axis = WPAD_Stick(data, 1, 1);
+		if(prev_state->wiimote.classicR_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 3, -(axis << 8));
+			prev_state->wiimote.classicR_stickY = axis;
+		}
+		axis = exp.classic.r_shoulder*255;
+		if(prev_state->wiimote.classic_triggerR != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+			prev_state->wiimote.classic_triggerR = axis;
+		}
+		axis = exp.classic.l_shoulder*255;
+		if(prev_state->wiimote.classic_triggerL != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+			prev_state->wiimote.classic_triggerL = axis;
+		}
+	}
+	else if(exp_type == WPAD_EXP_NUNCHUK)
+	{
+		axis = WPAD_Stick(data, 0, 0);
+		if(prev_state->wiimote.nunchuk_stickX != axis)
+		{
+			s16 value;
+			if (axis >= 128) value = AXIS_MAX;
+			else if (axis <=-128) value = AXIS_MIN;
+			else value = axis << 8;
+			SDL_PrivateJoystickAxis(joystick, 0, value);
+			prev_state->wiimote.nunchuk_stickX = axis;
+		}
+		axis = WPAD_Stick(data, 0, 1);
+		if(prev_state->wiimote.nunchuk_stickY != axis)
+		{
+			s16 value;
+			if (axis >= 128) value = AXIS_MAX;
+			else if (axis <=-128) value = AXIS_MIN;
+			else value = axis << 8;
+			SDL_PrivateJoystickAxis(joystick, 1, -value);
+			prev_state->wiimote.nunchuk_stickY = axis;
+		}
+	}
+
+	axis = WPAD_Pitch(data);
+	if(prev_state->wiimote.wiimote_pitch != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 6, -(axis << 8));
+		prev_state->wiimote.wiimote_pitch = axis;
+	}
+	axis = WPAD_Roll(data);
+	if(prev_state->wiimote.wiimote_roll != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 7, axis << 8);
+		prev_state->wiimote.wiimote_roll = axis;
+	}
+	axis = WPAD_Yaw(data);
+	if(prev_state->wiimote.wiimote_yaw != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 8, axis << 8);
+		prev_state->wiimote.wiimote_yaw = axis;
+	}
+}
+
+static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
+{
+	u16 buttons, prev_buttons, changed;
+	int i;
+	int axis;
+	joystick_hwdata *prev_state;
+
+	buttons = PAD_ButtonsHeld(joystick->index - 4);
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->gamecube.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP))
+	{
+		int hat = SDL_HAT_CENTERED;
+		if(buttons & PAD_BUTTON_UP) hat |= SDL_HAT_UP;
+		if(buttons & PAD_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+		if(buttons & PAD_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+		if(buttons & PAD_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++)
+	{
+		if (changed & sdl_buttons_gc[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->gamecube.prev_buttons = buttons;
+	axis = PAD_StickX(joystick->index-4);
+	if(prev_state->gamecube.stickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+		prev_state->gamecube.stickX = axis;
+	}
+
+	axis = PAD_StickY(joystick->index-4);
+	if(prev_state->gamecube.stickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+		prev_state->gamecube.stickY = axis;
+	}
+
+	axis = PAD_SubStickX(joystick->index-4);
+	if(prev_state->gamecube.substickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+		prev_state->gamecube.substickX = axis;
+	}
+
+	axis = PAD_SubStickY(joystick->index-4);
+	if(prev_state->gamecube.substickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+		prev_state->gamecube.substickY = axis;
+	}
+
+	axis = PAD_TriggerL(joystick->index-4);
+	if(prev_state->gamecube.triggerL != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+		prev_state->gamecube.triggerL = axis;
+	}
+
+	axis = PAD_TriggerR(joystick->index-4);
+	if(prev_state->gamecube.triggerR != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+		prev_state->gamecube.triggerR = axis;
+	}
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata)
+		return;
+
+	WPAD_ScanPads();
+	PAD_ScanPads();
+
+	switch(((joystick_hwdata*)(joystick->hwdata))->type)
+	{
+		case 0:
+		if(__jswpad_enabled)
+		_HandleWiiJoystickUpdate(joystick);
+		break;
+		case 1:
+		if(__jspad_enabled)
+		_HandleGCJoystickUpdate(joystick);
+		break;
+		default:
+		break;
+	}
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata) // joystick already closed
+		return;
+
+	SDL_free(joystick->hwdata);
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+
+}
+
+#endif /* SDL_JOYSTICK_DC */
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
new file mode 100644
index 000000000..a7b6c3af4
--- /dev/null
+++ b/src/main/wii/SDL_wii_main.c
@@ -0,0 +1,86 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/wii/SDL_wiivideo.h"
+
+/* OGC includes */
+#include <ogcsys.h>
+#include <wiiuse/wpad.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+
+bool TerminateRequested=false, ShutdownRequested=false, ResetRequested=false;
+
+#ifdef HW_RVL
+void SDL_Quit();
+static void ShutdownCB()
+{
+	TerminateRequested = 1;
+	ShutdownRequested = 1;
+}
+static void ResetCB()
+{
+	TerminateRequested = 1;
+	ResetRequested = 1;
+}
+void ShutdownWii()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	SYS_ResetSystem(SYS_POWEROFF, 0, 0);
+}
+void RestartHomebrewChannel()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	exit(1);
+}
+void Terminate()
+{
+	if (ShutdownRequested) ShutdownWii();
+	else if (ResetRequested) RestartHomebrewChannel();
+}
+#endif
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+#ifdef HW_RVL
+	L2Enhance();
+	u32 version = IOS_GetVersion();
+	s32 preferred = IOS_GetPreferredVersion();
+
+	if(preferred > 0 && version != (u32)preferred)
+		IOS_ReloadIOS(preferred);
+
+	// Wii Power/Reset buttons
+	WPAD_Init();
+	WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
+	SYS_SetPowerCallback(ShutdownCB);
+	SYS_SetResetCallback(ResetCB);
+#endif
+	PAD_Init();
+	WII_InitVideoSystem();
+#ifdef HW_RVL
+	WPAD_SetDataFormat(WPAD_CHAN_ALL,WPAD_FMT_BTNS_ACC_IR);
+	WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
+
+	MOUSE_Init();
+	KEYBOARD_Init(NULL);
+#endif
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
+
+/* This function isn't implemented */
+/*int unlink(const char* file_name)
+{
+	return -1;
+}
+*/
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 8af6e52f4..911756747 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -43,6 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
+#elif SDL_THREAD_WII
+#include "wii/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/wii/SDL_syscond.c b/src/thread/wii/SDL_syscond.c
new file mode 100644
index 000000000..27b403da2
--- /dev/null
+++ b/src/thread/wii/SDL_syscond.c
@@ -0,0 +1,139 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+#include "SDL_sysmutex_c.h"
+
+#include <ogcsys.h>
+#include <ogc/cond.h>
+
+struct SDL_cond
+{
+	cond_t cond;
+};
+
+/* Create a condition variable */
+SDL_cond * SDL_CreateCond(void)
+{
+	SDL_cond *cond;
+
+	cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+	if (cond)
+	{
+		if (LWP_CondInit(&(cond->cond)) < 0)
+		{
+			SDL_DestroyCond(cond);
+			cond = NULL;
+		}
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return (cond);
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+	if (cond)
+	{
+		LWP_CondDestroy(cond->cond);
+		SDL_free(cond);
+	}
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondSignal(cond->cond) == 0 ? 0 : -1;
+
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondBroadcast(cond->cond) == 0 ? 0 : -1;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+ The mutex must be locked before entering this function!
+ The mutex is unlocked during the wait, and locked again after the wait.
+
+ Typical use:
+
+ Thread A:
+ SDL_LockMutex(lock);
+ while ( ! condition ) {
+ SDL_CondWait(cond);
+ }
+ SDL_UnlockMutex(lock);
+
+ Thread B:
+ SDL_LockMutex(lock);
+ ...
+ condition = true;
+ ...
+ SDL_UnlockMutex(lock);
+ */
+
+
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+	struct timespec time; 
+
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+	//LWP_CondTimedWait expects relative timeout
+	time.tv_sec = (ms / 1000);
+	time.tv_nsec = (ms % 1000) * 1000000;
+
+	return LWP_CondTimedWait(cond->cond, mutex->id, &time);
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+	return LWP_CondWait(cond->cond, mutex->id);
+}
diff --git a/src/thread/wii/SDL_sysmutex.c b/src/thread/wii/SDL_sysmutex.c
new file mode 100644
index 000000000..f6e498286
--- /dev/null
+++ b/src/thread/wii/SDL_sysmutex.c
@@ -0,0 +1,87 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <ogcsys.h>
+
+struct SDL_mutex
+{
+	u32 id;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+	SDL_mutex *mutex = NULL;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+	if (mutex)
+	{
+		LWP_MutexInit(&mutex->id, 0);
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+	if (mutex)
+	{
+		LWP_MutexDestroy(mutex->id);
+		SDL_free(mutex);
+	}
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexLock(mutex->id);
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexUnlock(mutex->id);
+
+}
diff --git a/src/thread/wii/SDL_sysmutex_c.h b/src/thread/wii/SDL_sysmutex_c.h
new file mode 100644
index 000000000..9b37f359f
--- /dev/null
+++ b/src/thread/wii/SDL_sysmutex_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+struct SDL_mutex {
+	Uint32 id;
+};
diff --git a/src/thread/wii/SDL_syssem.c b/src/thread/wii/SDL_syssem.c
new file mode 100644
index 000000000..3a9e38407
--- /dev/null
+++ b/src/thread/wii/SDL_syssem.c
@@ -0,0 +1,175 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_semaphore
+{
+	Uint32 count;
+	Uint32 waiters_count;
+	SDL_mutex *count_lock;
+	SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_sem *sem;
+
+	sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+	if (!sem)
+	{
+		SDL_OutOfMemory();
+		return NULL;
+	}
+	sem->count = initial_value;
+	sem->waiters_count = 0;
+
+	sem->count_lock = SDL_CreateMutex();
+	sem->count_nonzero = SDL_CreateCond();
+	if (!sem->count_lock || !sem->count_nonzero)
+	{
+		SDL_DestroySemaphore(sem);
+		return NULL;
+	}
+
+	return sem;
+}
+
+/* WARNING:
+ You cannot call this function when another thread is using the semaphore.
+ */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+	if (sem)
+	{
+		sem->count = 0xFFFFFFFF;
+		while (sem->waiters_count > 0)
+		{
+			SDL_CondSignal(sem->count_nonzero);
+			SDL_Delay(10);
+		}
+		SDL_DestroyCond(sem->count_nonzero);
+		if (sem->count_lock)
+		{
+			SDL_mutexP(sem->count_lock);
+			SDL_mutexV(sem->count_lock);
+			SDL_DestroyMutex(sem->count_lock);
+		}
+		SDL_free(sem);
+	}
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	retval = SDL_MUTEX_TIMEDOUT;
+	SDL_LockMutex(sem->count_lock);
+	if (sem->count > 0)
+	{
+		--sem->count;
+		retval = 0;
+	}
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	/* A timeout of 0 is an easy case */
+	if (timeout == 0)
+	{
+		return SDL_SemTryWait(sem);
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	++sem->waiters_count;
+	retval = 0;
+	while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT))
+	{
+		retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock,
+				timeout);
+	}
+	--sem->waiters_count;
+	--sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+	return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+	Uint32 value;
+
+	value = 0;
+	if (sem)
+	{
+		SDL_LockMutex(sem->count_lock);
+		value = sem->count;
+		SDL_UnlockMutex(sem->count_lock);
+	}
+	return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	if (sem->waiters_count > 0)
+	{
+		SDL_CondSignal(sem->count_nonzero);
+	}
+	++sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return 0;
+}
diff --git a/src/thread/wii/SDL_systhread.c b/src/thread/wii/SDL_systhread.c
new file mode 100644
index 000000000..e720e91ac
--- /dev/null
+++ b/src/thread/wii/SDL_systhread.c
@@ -0,0 +1,80 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+
+#include <ogcsys.h>
+
+/*
+struct SDL_Thread {
+	Uint32 threadid;
+	SYS_ThreadHandle handle;
+	int status;
+	SDL_error errbuf;
+	void *data;
+};
+
+ */
+
+void *run_thread(void *data)
+{
+	SDL_RunThread(data);
+	return ((void *) 0); /* Prevent compiler warning */
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+	
+	if ( LWP_CreateThread(&thread->handle, run_thread, args, 0, 0, 64) != 0 ) {
+		SDL_SetError("Not enough resources to create thread");
+		return(-1);
+	}
+	
+	return (0);
+}
+
+void SDL_SYS_SetupThread(void)
+{
+	return;
+}
+
+Uint32 SDL_ThreadID(void)
+{
+	return (Uint32) LWP_GetSelf();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+	void *v;
+	LWP_JoinThread(thread->handle, &v);
+	return;
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+	return;
+}
diff --git a/src/thread/wii/SDL_systhread_c.h b/src/thread/wii/SDL_systhread_c.h
new file mode 100644
index 000000000..313544ca5
--- /dev/null
+++ b/src/thread/wii/SDL_systhread_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Stub until we implement threads on this platform */
+
+typedef Uint32 SYS_ThreadHandle;
diff --git a/src/timer/wii/SDL_systimer.c b/src/timer/wii/SDL_systimer.c
new file mode 100644
index 000000000..164178413
--- /dev/null
+++ b/src/timer/wii/SDL_systimer.c
@@ -0,0 +1,102 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_TIMER_WII
+
+#include <ogc/lwp_watchdog.h>
+#include <ogc/video.h>
+
+#include "SDL_timer.h"
+#include "../SDL_timer_c.h"
+
+#include <ogcsys.h>
+
+void SDL_StartTicks(void)
+{
+}
+
+Uint32 SDL_GetTicks (void)
+{
+	const Uint64 ticks	= gettime();
+	const Uint64 ms		= ticks / TB_TIMER_CLOCK;
+	return ms;
+}
+
+void SDL_Delay (Uint32 ms)
+{
+	struct timespec elapsed, tv;
+	elapsed.tv_sec = ms/1000;
+	elapsed.tv_nsec = (ms%1000)*1000000;
+	tv.tv_sec = elapsed.tv_sec;
+	tv.tv_nsec = elapsed.tv_nsec;
+	nanosleep(&tv, &elapsed);
+}
+
+#include "SDL_thread.h"
+
+/* Data to handle a single periodic alarm */
+static int timer_alive = 0;
+static SDL_Thread *timer = NULL;
+
+static int RunTimer(void *unused)
+{
+	while ( timer_alive ) {
+		if ( SDL_timer_running ) {
+			SDL_ThreadedTimerCheck();
+		}
+		SDL_Delay(1);
+	}
+	return(0);
+}
+
+/* This is only called if the event thread is not running */
+int SDL_SYS_TimerInit(void)
+{
+	timer_alive = 1;
+	timer = SDL_CreateThread(RunTimer, NULL);
+	if ( timer == NULL )
+		return(-1);
+	return(SDL_SetTimerThreaded(1));
+}
+
+void SDL_SYS_TimerQuit(void)
+{
+	timer_alive = 0;
+	if ( timer ) {
+		SDL_WaitThread(timer, NULL);
+		timer = NULL;
+	}
+}
+
+int SDL_SYS_StartTimer(void)
+{
+	SDL_SetError("Internal logic error: threaded timer in use");
+	return(-1);
+}
+
+void SDL_SYS_StopTimer(void)
+{
+	return;
+}
+
+#endif
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 436450e33..fd110e79f 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -410,6 +410,9 @@ extern VideoBootStrap AALIB_bootstrap;
 #if SDL_VIDEO_DRIVER_CACA
 extern VideoBootStrap CACA_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_WII
+extern VideoBootStrap WII_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 46285c990..a2441b75e 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -126,6 +126,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_CACA
 	&CACA_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_WII
+	&WII_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
diff --git a/src/video/wii/SDL_wiievents.c b/src/video/wii/SDL_wiievents.c
new file mode 100644
index 000000000..06ecec6e5
--- /dev/null
+++ b/src/video/wii/SDL_wiievents.c
@@ -0,0 +1,261 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+    Yohanes Nugroho (yohanes@gmail.com)
+	Tantric
+*/
+#include "SDL_config.h"
+
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include <wiiuse/wpad.h>
+#include <malloc.h>
+#include <unistd.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+
+#include "SDL_wiivideo.h"
+#include "SDL_wiievents_c.h"
+
+static Uint8 lastButtonStateA = SDL_RELEASED;
+static Uint8 lastButtonStateB = SDL_RELEASED;
+
+static SDLKey keymap[232];
+
+static s32 stat;
+static s32 mstat;
+static WPADData *wd;
+static int lastx = 0, lasty = 0;
+
+static keyboard_event ke;
+static mouse_event me;
+
+static int posted;
+
+extern bool TerminateRequested;
+extern void Terminate();
+
+void PumpEvents()
+{
+#ifdef HW_RVL
+	if (TerminateRequested) Terminate();
+#endif
+	wd = WPAD_Data(0);
+	stat = KEYBOARD_GetEvent(&ke);
+	mstat = MOUSE_GetEvent(&me);
+
+	if (wd->ir.valid)
+	{
+		int newx = wd->ir.x;
+		int newy = wd->ir.y;
+		int diffx = newx - lastx;
+		int diffy = newy - lasty;
+		lastx = newx;
+		lasty = newy;
+
+		posted += SDL_PrivateMouseMotion(0, 1, diffx, diffy);
+
+		Uint8 stateA = SDL_RELEASED;
+		Uint8 stateB = SDL_RELEASED;
+
+		if (wd->btns_h & WPAD_BUTTON_A)
+		{
+			stateA = SDL_PRESSED;
+		}
+		if (wd->btns_h & WPAD_BUTTON_B)
+		{
+			stateB = SDL_PRESSED;
+		}
+		if (stateA != lastButtonStateA)
+		{
+			lastButtonStateA = stateA;
+			posted += SDL_PrivateMouseButton(stateA, SDL_BUTTON_LEFT, 0, 0);
+		}
+		if (stateB != lastButtonStateB)
+		{
+			lastButtonStateB = stateB;
+			posted += SDL_PrivateMouseButton(stateB, SDL_BUTTON_RIGHT, 0, 0);
+		}
+	}
+
+	if (stat && (ke.type == KEYBOARD_RELEASED || ke.type == KEYBOARD_PRESSED))
+	{
+		SDL_keysym keysym;
+		memset(&keysym, 0, sizeof(keysym));
+		Uint8 keystate = (ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED
+				: SDL_RELEASED;
+		keysym.sym = keymap[ke.keycode];
+		keysym.mod = 0;
+		posted += SDL_PrivateKeyboard(keystate, &keysym);
+	}
+
+	if (mstat)
+	{
+		posted += SDL_PrivateMouseMotion(0, 1, me.rx, me.ry);
+
+		u8 button = me.button;
+
+		if (button & 0x1)
+		{
+			if (!(SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(1)))
+			{
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, 1, 0, 0);
+			}
+		}
+		else
+		{
+			if ((SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(1)))
+			{
+				posted += SDL_PrivateMouseButton(SDL_RELEASED, 1, 0, 0);
+			}
+		}
+
+		if (button & 0x2)
+		{
+			if (!(SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(3)))
+			{
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, 3, 0, 0);
+			}
+		}
+		else
+		{
+			if ((SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(3)))
+			{
+				posted += SDL_PrivateMouseButton(SDL_RELEASED, 3, 0, 0);
+			}
+		}
+	}
+}
+
+void WII_PumpEvents(_THIS)
+{
+	do
+	{
+		posted = 0;
+		PumpEvents();
+		usleep(100);
+	} while (posted);
+}
+
+void WII_InitOSKeymap(_THIS)
+{
+	int i;
+
+	for (i = 0; i < 232; ++i)
+		keymap[i] = SDLK_UNKNOWN;
+
+	// a-z
+	for (i = 0; i < 27; i++)
+		keymap[4 + i] = SDLK_a + i;
+
+	// 1-9
+	for (i = 0; i < 9; i++)
+		keymap[30 + i] = SDLK_1 + i;
+
+	keymap[39] = SDLK_0;
+	keymap[40] = SDLK_RETURN;
+	keymap[41] = SDLK_ESCAPE;
+	keymap[42] = SDLK_BACKSPACE;
+	keymap[43] = SDLK_TAB;
+	keymap[44] = SDLK_SPACE;
+	keymap[45] = SDLK_MINUS;
+	keymap[46] = SDLK_EQUALS;
+	keymap[47] = SDLK_LEFTBRACKET;
+	keymap[48] = SDLK_RIGHTBRACKET;
+	keymap[49] = SDLK_BACKSLASH;
+	keymap[50] = SDLK_UNKNOWN; // unused
+	keymap[51] = SDLK_SEMICOLON;
+	keymap[52] = SDLK_QUOTE;
+	keymap[53] = SDLK_BACKQUOTE;
+	keymap[54] = SDLK_COMMA;
+	keymap[55] = SDLK_PERIOD;
+	keymap[56] = SDLK_SLASH;
+	keymap[57] = SDLK_CAPSLOCK;
+
+	// F1 to F12
+	for (i = 0; i < 12; i++)
+		keymap[58 + i] = SDLK_F1 + i;
+
+	keymap[70] = SDLK_PRINT;
+	keymap[71] = SDLK_SCROLLOCK;
+	keymap[72] = SDLK_PAUSE;
+	keymap[73] = SDLK_INSERT;
+	keymap[74] = SDLK_HOME;
+	keymap[75] = SDLK_PAGEUP;
+	keymap[76] = SDLK_DELETE;
+	keymap[77] = SDLK_END;
+	keymap[78] = SDLK_PAGEDOWN;
+
+	keymap[79] = SDLK_RIGHT;
+	keymap[80] = SDLK_LEFT;
+	keymap[81] = SDLK_DOWN;
+	keymap[82] = SDLK_UP;
+	keymap[83] = SDLK_NUMLOCK;
+
+	keymap[84] = SDLK_KP_DIVIDE;
+	keymap[85] = SDLK_KP_MULTIPLY;
+	keymap[86] = SDLK_KP_MINUS;
+	keymap[87] = SDLK_KP_PLUS;
+
+	keymap[88] = SDLK_KP_ENTER;
+
+	// keypad 1-9
+	for (i = 0; i < 9; i++)
+		keymap[89 + i] = SDLK_KP1 + i;
+
+	keymap[98] = SDLK_KP0;
+	keymap[99] = SDLK_KP_PERIOD;
+	keymap[100] = SDLK_UNKNOWN; // unused
+	keymap[101] = SDLK_UNKNOWN; // Applic
+	keymap[102] = SDLK_POWER;
+	keymap[103] = SDLK_KP_EQUALS;
+	keymap[104] = SDLK_F13;
+	keymap[105] = SDLK_F14;
+	keymap[106] = SDLK_F15;
+	keymap[107] = SDLK_UNKNOWN; // F16
+	keymap[108] = SDLK_UNKNOWN; // F17
+	keymap[109] = SDLK_UNKNOWN; // F18
+	keymap[110] = SDLK_UNKNOWN; // F19
+	keymap[111] = SDLK_UNKNOWN; // F20
+	keymap[112] = SDLK_UNKNOWN; // F21
+	keymap[113] = SDLK_UNKNOWN; // F22
+	keymap[114] = SDLK_UNKNOWN; // F23
+	keymap[115] = SDLK_UNKNOWN; // F24
+	keymap[116] = SDLK_UNKNOWN; // Execute
+	keymap[117] = SDLK_HELP;
+	keymap[118] = SDLK_MENU;
+	keymap[119] = SDLK_UNKNOWN; // Select
+	keymap[120] = SDLK_UNKNOWN; // Stop
+	keymap[121] = SDLK_UNKNOWN; // Again
+	keymap[122] = SDLK_UNDO;
+
+	keymap[134] = SDLK_KP_EQUALS;
+	// 135-143 - International
+	// 144-152 - Language
+	keymap[154] = SDLK_SYSREQ;
+
+	keymap[224] = SDLK_LCTRL;
+	keymap[225] = SDLK_LSHIFT;
+	keymap[226] = SDLK_LALT;
+	keymap[227] = SDLK_LMETA;
+	keymap[228] = SDLK_RCTRL;
+	keymap[229] = SDLK_RSHIFT;
+	keymap[230] = SDLK_RALT;
+	keymap[231] = SDLK_RMETA;
+}
diff --git a/src/video/wii/SDL_wiievents_c.h b/src/video/wii/SDL_wiievents_c.h
new file mode 100644
index 000000000..f17f2b884
--- /dev/null
+++ b/src/video/wii/SDL_wiievents_c.h
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_wiivideo.h"
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern void WII_InitOSKeymap(_THIS);
+extern void WII_PumpEvents(_THIS);
+
+/* end of SDL_wiievents_c.h ... */
+
diff --git a/src/video/wii/SDL_wiimouse.c b/src/video/wii/SDL_wiimouse.c
new file mode 100644
index 000000000..fe380dda8
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse.c
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_wiimouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/wii/SDL_wiimouse_c.h b/src/video/wii/SDL_wiimouse_c.h
new file mode 100644
index 000000000..a890d392c
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_wiivideo.h"
+
+/* Functions to be exported */
diff --git a/src/video/wii/SDL_wiivideo.c b/src/video/wii/SDL_wiivideo.c
new file mode 100644
index 000000000..6cc82bd83
--- /dev/null
+++ b/src/video/wii/SDL_wiivideo.c
@@ -0,0 +1,866 @@
+/*
+	SDL - Simple DirectMedia Layer
+	Copyright (C) 1997-2006 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Lesser General Public
+	License as published by the Free Software Foundation; either
+	version 2.1 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+	Tantric, 2009
+*/
+#include "SDL_config.h"
+
+// Standard includes.
+#include <math.h>
+
+// SDL internal includes.
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+
+// SDL Wii specifics.
+#include <gccore.h>
+#include <ogcsys.h>
+#include <malloc.h>
+#include <ogc/texconv.h>
+#include <wiiuse/wpad.h>
+#include "SDL_wiivideo.h"
+#include "SDL_wiievents_c.h"
+
+static const char	WIIVID_DRIVER_NAME[] = "wii";
+static lwp_t videothread = LWP_THREAD_NULL;
+static SDL_mutex * videomutex = 0;
+
+/*** SDL ***/
+static SDL_Rect mode_320;
+static SDL_Rect mode_640;
+
+static SDL_Rect* modes_descending[] =
+{
+	&mode_640,
+	&mode_320,
+	NULL
+};
+
+/*** 2D Video ***/
+#define HASPECT 			320
+#define VASPECT 			240
+#define TEXTUREMEM_SIZE 	(640*480*4)
+
+unsigned int *xfb[2] = { NULL, NULL }; // Double buffered
+int whichfb = 0; // Switch
+GXRModeObj* vmode = 0;
+u8 * screenTex = NULL; // screen capture
+static int quit_flip_thread = 0;
+static unsigned char texturemem[TEXTUREMEM_SIZE] __attribute__((aligned(32))); // GX texture
+static unsigned char textureconvert[TEXTUREMEM_SIZE] __attribute__((aligned(32))); // 565 mem
+
+/*** GX ***/
+#define DEFAULT_FIFO_SIZE 256 * 1024
+static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
+static GXTexObj texobj;
+static Mtx view;
+
+/* New texture based scaler */
+typedef struct tagcamera
+{
+	guVector pos;
+	guVector up;
+	guVector view;
+}
+camera;
+
+/*** Square Matrix
+     This structure controls the size of the image on the screen.
+	 Think of the output as a -80 x 80 by -60 x 60 graph.
+***/
+static s16 square[] ATTRIBUTE_ALIGN (32) =
+{
+  /*
+   * X,   Y,  Z
+   * Values set are for roughly 4:3 aspect
+   */
+	-HASPECT,  VASPECT, 0,	// 0
+	 HASPECT,  VASPECT, 0,	// 1
+	 HASPECT, -VASPECT, 0,	// 2
+	-HASPECT, -VASPECT, 0	// 3
+};
+
+
+static camera cam = {
+	{0.0F, 0.0F, 0.0F},
+	{0.0F, 0.5F, 0.0F},
+	{0.0F, 0.0F, -0.5F}
+};
+
+/****************************************************************************
+ * Scaler Support Functions
+ ***************************************************************************/
+static int currentwidth;
+static int currentheight;
+static int currentbpp;
+
+static void
+draw_init ()
+{
+	GX_ClearVtxDesc ();
+	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
+	GX_SetVtxDesc (GX_VA_CLR0, GX_INDEX8);
+	GX_SetVtxDesc (GX_VA_TEX0, GX_DIRECT);
+
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
+
+	GX_SetNumTexGens (1);
+	GX_SetNumChans (0);
+
+	GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
+	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
+
+	memset (&view, 0, sizeof (Mtx));
+	guLookAt(view, &cam.pos, &cam.up, &cam.view);
+	GX_LoadPosMtxImm (view, GX_PNMTX0);
+
+	GX_InvVtxCache ();	// update vertex cache
+
+	// initialize the texture obj we are going to use
+	if (currentbpp == 8 || currentbpp == 16)
+		GX_InitTexObj (&texobj, texturemem, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
+	else
+		GX_InitTexObj (&texobj, texturemem, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+
+	GX_LoadTexObj (&texobj, GX_TEXMAP0);	// load texture object so its ready to use
+}
+
+static inline void
+draw_vert (u8 pos, u8 c, f32 s, f32 t)
+{
+	GX_Position1x8 (pos);
+	GX_Color1x8 (c);
+	GX_TexCoord2f32 (s, t);
+}
+
+static inline void
+draw_square (Mtx v)
+{
+	Mtx m;			// model matrix.
+	Mtx mv;			// modelview matrix.
+
+	guMtxIdentity (m);
+	guMtxTransApply (m, m, 0, 0, -100);
+	guMtxConcat (v, m, mv);
+
+	GX_LoadPosMtxImm (mv, GX_PNMTX0);
+	GX_Begin (GX_QUADS, GX_VTXFMT0, 4);
+	draw_vert (0, 0, 0.0, 0.0);
+	draw_vert (1, 0, 1.0, 0.0);
+	draw_vert (2, 0, 1.0, 1.0);
+	draw_vert (3, 0, 0.0, 1.0);
+	GX_End ();
+}
+
+/****************************************************************************
+ * TakeScreenshot
+ *
+ * Copies the current screen into a GX texture
+ ***************************************************************************/
+
+static void TakeScreenshot()
+{
+	int texSize = vmode->fbWidth * vmode->efbHeight * 4;
+
+	if(screenTex) free(screenTex);
+	screenTex = (u8 *)memalign(32, texSize);
+	if(screenTex == NULL) return;
+	GX_SetTexCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetTexCopyDst(vmode->fbWidth, vmode->efbHeight, GX_TF_RGBA8, GX_FALSE);
+	GX_CopyTex(screenTex, GX_FALSE);
+	GX_PixModeSync();
+	DCFlushRange(screenTex, texSize);
+}
+
+static void * flip_thread (void *arg)
+{
+	while(1)
+	{
+		if(quit_flip_thread == 2)
+			break;
+
+		// clear texture objects
+		GX_InvVtxCache();
+		GX_InvalidateTexAll();
+		
+		SDL_mutexP(videomutex);
+
+		// load texture into GX
+		DCFlushRange(texturemem, TEXTUREMEM_SIZE);
+
+		GX_LoadTexObj(&texobj, GX_TEXMAP0);
+
+		draw_square(view); // render textured quad
+		GX_SetColorUpdate(GX_TRUE);
+
+		if (quit_flip_thread == 1)
+		{
+			quit_flip_thread = 2;
+			TakeScreenshot();
+		}
+
+		whichfb ^= 1;
+
+		GX_CopyDisp(xfb[whichfb], GX_TRUE);
+		GX_DrawDone();
+		SDL_mutexV(videomutex);
+
+		VIDEO_SetNextFramebuffer(xfb[whichfb]);
+		VIDEO_Flush();
+		VIDEO_WaitVSync();
+	}
+	return NULL;
+}
+
+static void
+SetupGX()
+{
+	Mtx44 p;
+	int df = 1; // deflicker on/off
+
+	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
+	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
+	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
+
+	GX_SetDispCopySrc (0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetDispCopyDst (vmode->fbWidth, vmode->xfbHeight);
+	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
+
+	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+	GX_SetDispCopyGamma (GX_GM_1_0);
+	GX_SetCullMode (GX_CULL_NONE);
+	GX_SetBlendMode(GX_BM_BLEND,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
+
+	GX_SetZMode (GX_TRUE, GX_LEQUAL, GX_TRUE);
+	GX_SetColorUpdate (GX_TRUE);
+	GX_SetNumChans(1);
+
+	guOrtho(p, 480/2, -(480/2), -(640/2), 640/2, 100, 1000); // matrix, t, b, l, r, n, f
+	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
+}
+
+static void
+StartVideoThread()
+{
+	if(videothread == LWP_THREAD_NULL)
+	{
+		quit_flip_thread = 0;
+		LWP_CreateThread (&videothread, flip_thread, NULL, NULL, 0, 68);
+	}
+}
+
+static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	// Set up the modes.
+	mode_640.w = vmode->fbWidth;
+	mode_640.h = vmode->efbHeight;
+	mode_320.w = mode_640.w / 2;
+	mode_320.h = mode_640.h / 2;
+
+	// Set the current format.
+	vformat->BitsPerPixel	= 16;
+	vformat->BytesPerPixel	= 2;
+
+	this->hidden->buffer = NULL;
+	this->hidden->width = 0;
+	this->hidden->height = 0;
+	this->hidden->pitch = 0;
+
+	/* We're done! */
+	return(0);
+}
+
+static SDL_Rect **WII_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	return &modes_descending[0];
+}
+
+static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
+								   int width, int height, int bpp, Uint32 flags)
+{
+	SDL_Rect* 		mode;
+	size_t			bytes_per_pixel;
+	Uint32			r_mask = 0;
+	Uint32			b_mask = 0;
+	Uint32			g_mask = 0;
+
+	// Find a mode big enough to store the requested resolution
+	mode = modes_descending[0];
+	while (mode)
+	{
+		if (mode->w == width && mode->h == height)
+			break;
+		else
+			++mode;
+	}
+
+	// Didn't find a mode?
+	if (!mode)
+	{
+		SDL_SetError("Display mode (%dx%d) is unsupported.",
+			width, height);
+		return NULL;
+	}
+
+	if(bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
+	{
+		SDL_SetError("Resolution (%d bpp) is unsupported (8/16/24/32 bpp only).",
+			bpp);
+		return NULL;
+	}
+
+	bytes_per_pixel = bpp / 8;
+
+	// Free any existing buffer.
+	if (this->hidden->buffer)
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+	}
+
+	// Allocate the new buffer.
+	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
+	if (!this->hidden->buffer )
+	{
+		SDL_SetError("Couldn't allocate buffer for requested mode");
+		return(NULL);
+	}
+
+	// Allocate the new pixel format for the screen
+	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+
+		SDL_SetError("Couldn't allocate new pixel format for requested mode");
+		return(NULL);
+	}
+
+	// Clear the buffer
+	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
+
+	// Set up the new mode framebuffer
+	current->flags = (flags & SDL_DOUBLEBUF) | (flags & SDL_FULLSCREEN) | (flags & SDL_HWPALETTE);
+	current->w = width;
+	current->h = height;
+	current->pitch = current->w * bytes_per_pixel;
+	current->pixels = this->hidden->buffer;
+
+	/* Set the hidden data */
+	this->hidden->width = current->w;
+	this->hidden->height = current->h;
+	this->hidden->pitch = current->pitch;
+
+	currentwidth = current->w;
+	currentheight = current->h;
+	currentbpp = bpp;
+	WPAD_SetVRes(WPAD_CHAN_ALL, currentwidth*1.5, currentheight*1.5);
+	draw_init();
+	StartVideoThread();
+	/* We're done */
+	return(current);
+}
+
+/* We don't actually allow hardware surfaces other than the main one */
+static int WII_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+
+static void WII_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static int WII_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+
+static void WII_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
+{
+	u8 *truc = (u8*) texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+
+	*(truc + offset) = color & 0xFF;
+	*(truc + offset + 1) = (color >> 24) & 0xFF;
+	*(truc + offset + 32) = (color >> 16) & 0xFF;
+	*(truc + offset + 33) = (color >> 8) & 0xFF;
+}
+
+static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
+{
+	u8 *truc = (u8*) texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + (((y % 4 << 2) + x % 4) << 1);
+
+	*(truc + offset) = (color >> 8) & 0xFF;
+	*(truc + offset + 1) = color & 0xFF;
+}
+
+static void UpdateRect_8(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u16 color;
+	int i, j;
+	Uint16 *palette = this->hidden->palette;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + (rect->x));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + j;
+			color = palette[*ptr];
+			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_16(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u16 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 2 * (i + rect->y)) + (rect->x * 2));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 2);
+			color = (ptr[0] << 8) | ptr[1];
+			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_24(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 3 * (i + rect->y)) + (rect->x * 3));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 3);
+			color = (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | 0xff;
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_32(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 4 * (i + rect->y)) + (rect->x * 4));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 4);
+			color = (ptr[1] << 24) | (ptr[2] << 16) | (ptr[3] << 8) | ptr[0];
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void WII_UpdateRect(_THIS, SDL_Rect *rect)
+{
+	const SDL_Surface* const screen = this->screen;
+	SDL_mutexP(videomutex);
+	switch(screen->format->BytesPerPixel) {
+	case 1:
+		UpdateRect_8(this, rect);
+		break;
+	case 2:
+		UpdateRect_16(this, rect);
+		break;
+	case 3:
+		UpdateRect_24(this, rect);
+		break;
+	case 4:
+		UpdateRect_32(this, rect);
+		break;
+	default:
+		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
+		break;
+	}
+	SDL_mutexV(videomutex);
+}
+
+static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+	int i;
+	for (i = 0; i < numrects; i++)
+	{
+		WII_UpdateRect(this, &rects[i]);
+	}
+}
+
+static void flipHWSurface_8_16(_THIS, SDL_Surface *surface)
+{
+	int new_pitch = this->hidden->width * 2;
+	long long int *dst = (long long int *) texturemem;
+	long long int *src1 = (long long int *) textureconvert;
+	long long int *src2 = (long long int *) (textureconvert + new_pitch);
+	long long int *src3 = (long long int *) (textureconvert + (new_pitch * 2));
+	long long int *src4 = (long long int *) (textureconvert + (new_pitch * 3));
+	int rowpitch = (new_pitch >> 3) * 3;
+	int rowadjust = (new_pitch % 8) * 4;
+	Uint16 *palette = this->hidden->palette;
+	char *ra = NULL;
+	int h, w;
+
+	// crude convert
+	Uint16 * ptr_cv = (Uint16 *) textureconvert;
+	Uint8 *ptr = (Uint8 *)this->hidden->buffer;
+
+	for (h = 0; h < this->hidden->height; h++)
+	{
+		for (w = 0; w < this->hidden->width; w++)
+		{
+			Uint16 v = palette[*ptr];
+
+			*ptr_cv++ = v;
+			ptr++;
+		}
+	}
+
+	// same as 16bit
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < (this->hidden->width >> 2); w++)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 += rowpitch;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+
+		if ( rowadjust )
+		{
+			ra = (char *)src1;
+			src1 = (long long int *)(ra + rowadjust);
+			ra = (char *)src2;
+			src2 = (long long int *)(ra + rowadjust);
+			ra = (char *)src3;
+			src3 = (long long int *)(ra + rowadjust);
+			ra = (char *)src4;
+			src4 = (long long int *)(ra + rowadjust);
+		}
+	}
+}
+
+static void flipHWSurface_16_16(_THIS, SDL_Surface *surface)
+{
+	int h, w;
+	long long int *dst = (long long int *) texturemem;
+	long long int *src1 = (long long int *) this->hidden->buffer;
+	long long int *src2 = (long long int *) (this->hidden->buffer + this->hidden->pitch);
+	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
+	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
+	int rowpitch = (this->hidden->pitch >> 3) * 3;
+	int rowadjust = (this->hidden->pitch % 8) * 4;
+	char *ra = NULL;
+
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < this->hidden->width; w += 4)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 += rowpitch;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+
+		if ( rowadjust )
+		{
+			ra = (char *)src1;
+			src1 = (long long int *)(ra + rowadjust);
+			ra = (char *)src2;
+			src2 = (long long int *)(ra + rowadjust);
+			ra = (char *)src3;
+			src3 = (long long int *)(ra + rowadjust);
+			ra = (char *)src4;
+			src4 = (long long int *)(ra + rowadjust);
+		}
+	}
+}
+
+static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	WII_UpdateRect(this, &screen_rect);
+}
+
+static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	WII_UpdateRect(this, &screen_rect);
+}
+
+static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+	switch(surface->format->BytesPerPixel)
+	{
+		case 1:
+			flipHWSurface_8_16(this, surface);
+			break;
+		case 2:
+			flipHWSurface_16_16(this, surface);
+			break;
+		case 3:
+			flipHWSurface_24_16(this, surface);
+			break;
+		case 4:
+			flipHWSurface_32_16(this, surface);
+			break;
+		default:
+			return -1;
+	}
+	return 1;
+}
+
+static int WII_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
+{
+	const int last_color = first_color + color_count;
+	Uint16* const palette = this->hidden->palette;
+	int     component;
+
+	/* Build the RGB565 palette. */
+	for (component = first_color; component != last_color; ++component)
+	{
+		const SDL_Color* const in = &colors[component - first_color];
+		const unsigned int r    = (in->r >> 3) & 0x1f;
+		const unsigned int g    = (in->g >> 2) & 0x3f;
+		const unsigned int b    = (in->b >> 3) & 0x1f;
+
+		palette[component] = (r << 11) | (g << 5) | b;
+	}
+
+	return(1);
+}
+
+static void WII_VideoQuit(_THIS)
+{
+	WII_VideoStop();
+	GX_AbortFrame();
+	GX_Flush();
+
+	VIDEO_SetBlack(TRUE);
+	VIDEO_Flush();
+}
+
+static void WII_DeleteDevice(SDL_VideoDevice *device)
+{
+	SDL_free(device->hidden);
+	SDL_free(device);
+}
+
+static SDL_VideoDevice *WII_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+			SDL_malloc((sizeof *device->hidden));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( device ) {
+			SDL_free(device);
+		}
+		return(0);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+	videomutex = SDL_CreateMutex();
+
+	/* Set the function pointers */
+	device->VideoInit = WII_VideoInit;
+	device->ListModes = WII_ListModes;
+	device->SetVideoMode = WII_SetVideoMode;
+	device->CreateYUVOverlay = NULL;
+	device->SetColors = WII_SetColors;
+	device->UpdateRects = WII_UpdateRects;
+	device->VideoQuit = WII_VideoQuit;
+	device->AllocHWSurface = WII_AllocHWSurface;
+	device->CheckHWBlit = NULL;
+	device->FillHWRect = NULL;
+	device->SetHWColorKey = NULL;
+	device->SetHWAlpha = NULL;
+	device->LockHWSurface = WII_LockHWSurface;
+	device->UnlockHWSurface = WII_UnlockHWSurface;
+	device->FlipHWSurface = WII_FlipHWSurface;
+	device->FreeHWSurface = WII_FreeHWSurface;
+	device->SetCaption = NULL;
+	device->SetIcon = NULL;
+	device->IconifyWindow = NULL;
+	device->GrabInput = NULL;
+	device->GetWMInfo = NULL;
+	device->InitOSKeymap = WII_InitOSKeymap;
+	device->PumpEvents = WII_PumpEvents;
+
+	device->free = WII_DeleteDevice;
+
+	return device;
+}
+
+static int WII_Available(void)
+{
+	return(1);
+}
+
+VideoBootStrap WII_bootstrap = {
+	WIIVID_DRIVER_NAME, "Wii video driver",
+	WII_Available, WII_CreateDevice
+};
+
+void
+WII_InitVideoSystem()
+{
+	/* Initialise the video system */
+	VIDEO_Init();
+	vmode = VIDEO_GetPreferredMode(NULL);
+
+	/* Set up the video system with the chosen mode */
+	VIDEO_Configure(vmode);
+
+	// Allocate the video buffers
+	xfb[0] = (u32 *) SYS_AllocateFramebuffer (vmode);
+	xfb[1] = (u32 *) SYS_AllocateFramebuffer (vmode);
+	DCInvalidateRange(xfb[0], VIDEO_GetFrameBufferSize(vmode));
+	DCInvalidateRange(xfb[1], VIDEO_GetFrameBufferSize(vmode));
+	xfb[0] = (u32 *) MEM_K0_TO_K1 (xfb[0]);
+	xfb[1] = (u32 *) MEM_K0_TO_K1 (xfb[1]);
+
+	VIDEO_ClearFrameBuffer(vmode, xfb[0], COLOR_BLACK);
+	VIDEO_ClearFrameBuffer(vmode, xfb[1], COLOR_BLACK);
+	VIDEO_SetNextFramebuffer (xfb[0]);
+
+	// Show the screen.
+	VIDEO_SetBlack(FALSE);
+	VIDEO_Flush();
+	VIDEO_WaitVSync();
+	if (vmode->viTVMode & VI_NON_INTERLACE)
+			VIDEO_WaitVSync();
+		else
+			while (VIDEO_GetNextField())
+				VIDEO_WaitVSync();
+
+	CON_Init(xfb[0],20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
+
+	/*** Clear out FIFO area ***/
+	memset (&gp_fifo, 0, DEFAULT_FIFO_SIZE);
+
+	/*** Initialise GX ***/
+	GX_Init (&gp_fifo, DEFAULT_FIFO_SIZE);
+
+	GXColor background = { 0, 0, 0, 0xff };
+	GX_SetCopyClear (background, 0x00ffffff);
+
+	SetupGX();
+}
+
+void WII_SetWidescreen(int wide)
+{
+	if(wide)
+	{
+		vmode->viWidth = 678;
+		vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - 678) / 2;
+	}
+	else
+	{
+		vmode->viWidth = 640;
+		vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - 640) / 2;
+	}
+	VIDEO_Configure (vmode);
+	VIDEO_Flush();
+	
+	VIDEO_WaitVSync ();
+		
+	if (vmode->viTVMode & VI_NON_INTERLACE)
+		VIDEO_WaitVSync();
+	else
+		while (VIDEO_GetNextField())
+			VIDEO_WaitVSync();
+}
+
+void WII_VideoStart()
+{
+	SetupGX();
+	draw_init();
+	StartVideoThread();
+	WPAD_SetVRes(WPAD_CHAN_ALL, currentwidth*2, currentheight*2);
+}
+
+void WII_VideoStop()
+{
+	quit_flip_thread = 1;
+	if(videothread == LWP_THREAD_NULL) return;
+	LWP_JoinThread(videothread, NULL);
+	videothread = LWP_THREAD_NULL;
+}
+
+void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
+{
+	square[6] = square[3]  =  xscale + xshift;
+	square[0] = square[9]  = -xscale + xshift;
+	square[4] = square[1]  =  yscale - yshift;
+	square[7] = square[10] = -yscale - yshift;
+	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
+}
diff --git a/src/video/wii/SDL_wiivideo.h b/src/video/wii/SDL_wiivideo.h
new file mode 100644
index 000000000..d893706ac
--- /dev/null
+++ b/src/video/wii/SDL_wiivideo.h
@@ -0,0 +1,51 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Tantric, 2009
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_wiivideo_h
+#define _SDL_wiivideo_h
+
+/* SDL internal includes */
+#include "../SDL_sysvideo.h"
+
+/* OGC includes */
+#include <ogc/gx_struct.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS	SDL_VideoDevice *this
+
+/* Private display data */
+struct SDL_PrivateVideoData
+{
+	Uint8*					buffer;
+	int						width;
+	int						height;
+	int						pitch;
+
+	Uint16             palette[256];
+};
+
+void WII_InitVideoSystem();
+void WII_VideoStart();
+void WII_VideoStop();
+void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
+
+#endif /* _SDL_wiivideo_h */
-- 
2.30.2


From fde6a79d3b33274fb1d5b96203dee1fa21d4585c Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Fri, 12 Jun 2020 17:02:43 +0200
Subject: [PATCH 02/24] Update configure stuff for Wii

---
 configure.in            | 39 +++++++++++++++++++++++++++++++++++++++
 include/SDL_config.h.in |  5 +++++
 2 files changed, 44 insertions(+)

diff --git a/configure.in b/configure.in
index 08c8e1e97..7e913a109 100644
--- a/configure.in
+++ b/configure.in
@@ -925,6 +925,42 @@ AC_HELP_STRING([--enable-ipod], [configure SDL to work with iPodLinux [[default=
     fi
 }
 
+CheckNintendoWii()
+{
+    AC_ARG_ENABLE(nintendo-wii,
+AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_wii = xyes; then
+        ARCH=nintendo-wii
+        WII_CFLAGS="-mrvl -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $WII_CFLAGS"
+        CFLAGS="$CFLAGS $WII_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $WII_CFLAGS"
+        SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/wii/lib $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib -logc"
+        AC_DEFINE(SDL_TIMER_WII)
+        SOURCES="$SOURCES $srcdir/src/timer/wii/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_WII)
+        SOURCES="$SOURCES $srcdir/src/audio/wii/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_WII)
+        SOURCES="$SOURCES $srcdir/src/joystick/wii/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_WII)
+        SOURCES="$SOURCES $srcdir/src/thread/wii/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_WII)
+        SOURCES="$SOURCES $srcdir/src/video/wii/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/wii/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -2314,6 +2350,9 @@ AC_HELP_STRING([--enable-rpath], [use an rpath when linking SDL [[default=yes]]]
 
 dnl Set up the configuration based on the host platform!
 case "$host" in
+    powerpc-*-eabi)
+       CheckNintendoWii
+       ;;
     arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
         ARCH=linux
         CheckDummyVideo
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 8bb1773c0..6db1d6b26 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -185,6 +185,7 @@
 #undef SDL_AUDIO_DRIVER_SNDMGR
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WAVEOUT
+#undef SDL_AUDIO_DRIVER_WII
 
 /* Enable various cdrom drivers */
 #undef SDL_CDROM_AIX
@@ -215,6 +216,7 @@
 #undef SDL_JOYSTICK_MINT
 #undef SDL_JOYSTICK_OS2
 #undef SDL_JOYSTICK_RISCOS
+#undef SDL_JOYSTICK_WII
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
@@ -238,6 +240,7 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_SPROC
+#undef SDL_THREAD_WII
 #undef SDL_THREAD_WIN32
 
 /* Enable various timer systems */
@@ -249,6 +252,7 @@
 #undef SDL_TIMER_OS2
 #undef SDL_TIMER_RISCOS
 #undef SDL_TIMER_UNIX
+#undef SDL_TIMER_WII
 #undef SDL_TIMER_WIN32
 #undef SDL_TIMER_WINCE
 
@@ -279,6 +283,7 @@
 #undef SDL_VIDEO_DRIVER_SVGALIB
 #undef SDL_VIDEO_DRIVER_TOOLBOX
 #undef SDL_VIDEO_DRIVER_VGL
+#undef SDL_VIDEO_DRIVER_WII
 #undef SDL_VIDEO_DRIVER_WINDIB
 #undef SDL_VIDEO_DRIVER_WSCONS
 #undef SDL_VIDEO_DRIVER_X11
-- 
2.30.2


From 7d78bf5cdf3d09d4c84cb1e0d1351e79ab20de11 Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Sat, 13 Jun 2020 13:57:01 +0200
Subject: [PATCH 03/24] Add widescreen mode and only redraw screen when needed

---
 src/video/wii/SDL_wiivideo.c | 105 ++++++++++++++++++++---------------
 1 file changed, 61 insertions(+), 44 deletions(-)

diff --git a/src/video/wii/SDL_wiivideo.c b/src/video/wii/SDL_wiivideo.c
index 6cc82bd83..2e8a493bc 100644
--- a/src/video/wii/SDL_wiivideo.c
+++ b/src/video/wii/SDL_wiivideo.c
@@ -40,14 +40,17 @@
 
 static const char	WIIVID_DRIVER_NAME[] = "wii";
 static lwp_t videothread = LWP_THREAD_NULL;
-static SDL_mutex * videomutex = 0;
+static SDL_mutex *videomutex = 0;
+static SDL_cond *videocond = NULL;
 
 /*** SDL ***/
 static SDL_Rect mode_320;
 static SDL_Rect mode_640;
+static SDL_Rect mode_848;
 
 static SDL_Rect* modes_descending[] =
 {
+	&mode_848,
 	&mode_640,
 	&mode_320,
 	NULL
@@ -70,7 +73,6 @@ static unsigned char textureconvert[TEXTUREMEM_SIZE] __attribute__((aligned(32))
 #define DEFAULT_FIFO_SIZE 256 * 1024
 static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
 static GXTexObj texobj;
-static Mtx view;
 
 /* New texture based scaler */
 typedef struct tagcamera
@@ -114,6 +116,8 @@ static int currentbpp;
 static void
 draw_init ()
 {
+	Mtx m, mv, view;
+
 	GX_ClearVtxDesc ();
 	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
 	GX_SetVtxDesc (GX_VA_CLR0, GX_INDEX8);
@@ -135,6 +139,9 @@ draw_init ()
 
 	memset (&view, 0, sizeof (Mtx));
 	guLookAt(view, &cam.pos, &cam.up, &cam.view);
+	guMtxIdentity(m);
+	guMtxTransApply(m, m, 0, 0, -100);
+	guMtxConcat(view, m, mv);
 	GX_LoadPosMtxImm (view, GX_PNMTX0);
 
 	GX_InvVtxCache ();	// update vertex cache
@@ -157,16 +164,8 @@ draw_vert (u8 pos, u8 c, f32 s, f32 t)
 }
 
 static inline void
-draw_square (Mtx v)
+draw_square ()
 {
-	Mtx m;			// model matrix.
-	Mtx mv;			// modelview matrix.
-
-	guMtxIdentity (m);
-	guMtxTransApply (m, m, 0, 0, -100);
-	guMtxConcat (v, m, mv);
-
-	GX_LoadPosMtxImm (mv, GX_PNMTX0);
 	GX_Begin (GX_QUADS, GX_VTXFMT0, 4);
 	draw_vert (0, 0, 0.0, 0.0);
 	draw_vert (1, 0, 1.0, 0.0);
@@ -197,41 +196,32 @@ static void TakeScreenshot()
 
 static void * flip_thread (void *arg)
 {
-	while(1)
-	{
-		if(quit_flip_thread == 2)
-			break;
+	u32 *tex = (u32*)arg;
 
-		// clear texture objects
-		GX_InvVtxCache();
-		GX_InvalidateTexAll();
-		
-		SDL_mutexP(videomutex);
+	GX_SetCurrentGXThread();
 
-		// load texture into GX
-		DCFlushRange(texturemem, TEXTUREMEM_SIZE);
+	// clear EFB
+	GX_CopyDisp(xfb, GX_TRUE);
 
-		GX_LoadTexObj(&texobj, GX_TEXMAP0);
-
-		draw_square(view); // render textured quad
-		GX_SetColorUpdate(GX_TRUE);
+	SDL_mutexP(videomutex);
 
-		if (quit_flip_thread == 1)
-		{
-			quit_flip_thread = 2;
-			TakeScreenshot();
-		}
+	while(!quit_flip_thread)
+	{
+		// update texture
+		DCStoreRange((void*)tex[0], tex[1]);
+		// clear texture objects
+		GX_InvalidateTexAll();
+		draw_square(); // render textured quad
 
-		whichfb ^= 1;
+		VIDEO_WaitVSync();
+		GX_CopyDisp(xfb, GX_FALSE);
 
-		GX_CopyDisp(xfb[whichfb], GX_TRUE);
 		GX_DrawDone();
-		SDL_mutexV(videomutex);
 
-		VIDEO_SetNextFramebuffer(xfb[whichfb]);
-		VIDEO_Flush();
-		VIDEO_WaitVSync();
+		SDL_CondWait(videocond, videomutex);
 	}
+	SDL_mutexV(videomutex);
+
 	return NULL;
 }
 
@@ -276,10 +266,12 @@ StartVideoThread()
 static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
 {
 	// Set up the modes.
-	mode_640.w = vmode->fbWidth;
-	mode_640.h = vmode->efbHeight;
-	mode_320.w = mode_640.w / 2;
-	mode_320.h = mode_640.h / 2;
+	mode_848.w = 848;
+	mode_848.h = 480;
+	mode_640.w = 640;
+	mode_640.h = 480;
+	mode_320.w = 320;
+	mode_320.h = 240;
 
 	// Set the current format.
 	vformat->BitsPerPixel	= 16;
@@ -296,7 +288,7 @@ static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
 
 static SDL_Rect **WII_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
 {
-	return &modes_descending[0];
+	return modes_descending;
 }
 
 static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
@@ -364,7 +356,9 @@ static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
 	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
 
 	// Set up the new mode framebuffer
-	current->flags = (flags & SDL_DOUBLEBUF) | (flags & SDL_FULLSCREEN) | (flags & SDL_HWPALETTE);
+	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME);
+	// Our surface is always double buffered
+	current->flags |= SDL_PREALLOC | SDL_DOUBLEBUF;
 	current->w = width;
 	current->h = height;
 	current->pitch = current->w * bytes_per_pixel;
@@ -532,10 +526,16 @@ static void WII_UpdateRect(_THIS, SDL_Rect *rect)
 static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
 {
 	int i;
+
+	// note that this function doesn't lock - we don't care if this isn't
+	// rendered now, that's what Flip is for
+
 	for (i = 0; i < numrects; i++)
 	{
 		WII_UpdateRect(this, &rects[i]);
 	}
+
+	SDL_CondSignal(videocond);
 }
 
 static void flipHWSurface_8_16(_THIS, SDL_Surface *surface)
@@ -609,6 +609,8 @@ static void flipHWSurface_16_16(_THIS, SDL_Surface *surface)
 	int rowadjust = (this->hidden->pitch % 8) * 4;
 	char *ra = NULL;
 
+	SDL_mutexP(videomutex);
+
 	for (h = 0; h < this->hidden->height; h += 4)
 	{
 		for (w = 0; w < this->hidden->width; w += 4)
@@ -636,6 +638,9 @@ static void flipHWSurface_16_16(_THIS, SDL_Surface *surface)
 			src4 = (long long int *)(ra + rowadjust);
 		}
 	}
+
+	SDL_CondSignal(videocond);
+	SDL_mutexV(videomutex);
 }
 
 static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
@@ -706,6 +711,11 @@ static void WII_DeleteDevice(SDL_VideoDevice *device)
 {
 	SDL_free(device->hidden);
 	SDL_free(device);
+
+	SDL_DestroyCond(videocond);
+	videocond = 0;
+	SDL_DestroyMutex(videomutex);
+	videomutex=0;
 }
 
 static SDL_VideoDevice *WII_CreateDevice(int devindex)
@@ -729,6 +739,7 @@ static SDL_VideoDevice *WII_CreateDevice(int devindex)
 	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
 
 	videomutex = SDL_CreateMutex();
+	videocond = SDL_CreateCond();
 
 	/* Set the function pointers */
 	device->VideoInit = WII_VideoInit;
@@ -850,8 +861,14 @@ void WII_VideoStart()
 
 void WII_VideoStop()
 {
+	if(videothread == LWP_THREAD_NULL)
+		return;
+
+	SDL_LockMutex(videomutex);
 	quit_flip_thread = 1;
-	if(videothread == LWP_THREAD_NULL) return;
+	SDL_CondSignal(videocond);
+	SDL_UnlockMutex(videomutex);
+
 	LWP_JoinThread(videothread, NULL);
 	videothread = LWP_THREAD_NULL;
 }
-- 
2.30.2


From 662e60ec9306065ddf54061db88fdaed9d795edc Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Sat, 13 Jun 2020 18:11:56 +0200
Subject: [PATCH 04/24] Pick improvements tueidj made on Wii's SDL for CorsixTH

---
 src/joystick/wii/SDL_sysjoystick.c | 319 +++++++++--------
 src/main/wii/SDL_wii_main.c        |   2 +
 src/video/wii/SDL_wiievents.c      | 132 ++++---
 src/video/wii/SDL_wiivideo.c       | 529 ++++++++++++++---------------
 src/video/wii/SDL_wiivideo.h       |  26 +-
 5 files changed, 495 insertions(+), 513 deletions(-)

diff --git a/src/joystick/wii/SDL_sysjoystick.c b/src/joystick/wii/SDL_sysjoystick.c
index fb7c693a4..1b9ce8f5d 100644
--- a/src/joystick/wii/SDL_sysjoystick.c
+++ b/src/joystick/wii/SDL_sysjoystick.c
@@ -44,12 +44,12 @@
 #define	MAX_GC_HATS			1
 
 #define MAX_WII_AXES		9
-#define MAX_WII_BUTTONS		20
+#define MAX_WII_BUTTONS		15
 #define	MAX_WII_HATS		1
 
 #define	JOYNAMELEN			10
 
-#define AXIS_MIN	-32768  /* minimum value for axis coordinate */
+#define AXIS_MIN	-32767  /* minimum value for axis coordinate */
 #define AXIS_MAX	32767   /* maximum value for axis coordinate */
 
 typedef struct joystick_paddata_t
@@ -66,17 +66,20 @@ typedef struct joystick_paddata_t
 typedef struct joystick_wpaddata_t
 {
 	u32 prev_buttons;
-	s8 nunchuk_stickX;
-	s8 nunchuk_stickY;
-	s8 classicL_stickX;
-	s8 classicL_stickY;
-	s8 classicR_stickX;
-	s8 classicR_stickY;
+	u32 exp;
+	s16 nunchuk_stickX;
+	s16 nunchuk_stickY;
+	s16 classicL_stickX;
+	s16 classicL_stickY;
+	s16 classicR_stickX;
+	s16 classicR_stickY;
 	u8 classic_triggerL;
 	u8 classic_triggerR;
+	u8 classic_calibrated;
 	s8 wiimote_pitch;
 	s8 wiimote_roll;
 	s8 wiimote_yaw;
+	s16 classic_cal[4][3]; // 4x axes, min/center/max
 }joystick_wpaddata;
 
 /* The private structure used to keep track of a joystick */
@@ -93,38 +96,38 @@ typedef struct joystick_hwdata_t
 
 static const u32 sdl_buttons_wii[] =
 {
-	WPAD_BUTTON_A,
-	WPAD_BUTTON_B,
+	WPAD_BUTTON_A|WPAD_CLASSIC_BUTTON_A,
+	WPAD_BUTTON_B|WPAD_CLASSIC_BUTTON_B,
 	WPAD_BUTTON_1,
 	WPAD_BUTTON_2,
-	WPAD_BUTTON_MINUS,
-	WPAD_BUTTON_PLUS,
-	WPAD_BUTTON_HOME,
+	WPAD_BUTTON_MINUS|WPAD_CLASSIC_BUTTON_MINUS,
+	WPAD_BUTTON_PLUS|WPAD_CLASSIC_BUTTON_PLUS,
+	WPAD_BUTTON_HOME|WPAD_CLASSIC_BUTTON_HOME,
 	WPAD_NUNCHUK_BUTTON_Z, /* 7 */
 	WPAD_NUNCHUK_BUTTON_C, /* 8 */
-	WPAD_CLASSIC_BUTTON_A, /* 9 */
-	WPAD_CLASSIC_BUTTON_B,
-	WPAD_CLASSIC_BUTTON_X,
+	WPAD_CLASSIC_BUTTON_X, /* 9 */
 	WPAD_CLASSIC_BUTTON_Y,
 	WPAD_CLASSIC_BUTTON_FULL_L,
 	WPAD_CLASSIC_BUTTON_FULL_R,
 	WPAD_CLASSIC_BUTTON_ZL,
-	WPAD_CLASSIC_BUTTON_ZR,
-	WPAD_CLASSIC_BUTTON_MINUS,
-	WPAD_CLASSIC_BUTTON_PLUS,
-	WPAD_CLASSIC_BUTTON_HOME
+	WPAD_CLASSIC_BUTTON_ZR
 };
 
 static const u16 sdl_buttons_gc[] =
 {
 	PAD_BUTTON_A,
 	PAD_BUTTON_B,
+	0 /* 1 */,
+	0 /* 2 */,
+	0 /* - */,
+	PAD_TRIGGER_Z,
+	PAD_BUTTON_START,
+	0 /* Z */,
+	0 /* C */,
 	PAD_BUTTON_X,
 	PAD_BUTTON_Y,
-	PAD_TRIGGER_Z,
-	PAD_TRIGGER_R,
 	PAD_TRIGGER_L,
-	PAD_BUTTON_START
+	PAD_TRIGGER_R
 };
 
 static int __jswpad_enabled = 1;
@@ -237,182 +240,204 @@ static s16 WPAD_Yaw(WPADData *data)
 	return WPAD_Orient(data, 2);
 }
 
-static s16 WPAD_Stick(WPADData *data, u8 right, int axis)
+static s16 WPAD_Stick(s16 x, s16 min, s16 center, s16 max, int flip)
 {
-	float mag = 0.0;
-	float ang = 0.0;
+	s16 d;
+	int ret;
 
-	switch (data->exp.type)
-	{
-		case WPAD_EXP_NUNCHUK:
-		case WPAD_EXP_GUITARHERO3:
-			if (right == 0)
-			{
-				mag = data->exp.nunchuk.js.mag;
-				ang = data->exp.nunchuk.js.ang;
-			}
-			break;
-
-		case WPAD_EXP_CLASSIC:
-			if (right == 0)
-			{
-				mag = data->exp.classic.ljs.mag;
-				ang = data->exp.classic.ljs.ang;
-			}
-			else
-			{
-				mag = data->exp.classic.rjs.mag;
-				ang = data->exp.classic.rjs.ang;
-			}
-			break;
+	x -= center;
 
-		default:
-			break;
-	}
+	if (x < 0)
+		d = center - min;
+	else
+		d = max - center;
+
+	if (center - min < 5) return 0;
+	if (max - center < 5) return 0;
+
+	if (d)
+		ret = (x << 15) / d;
+	else
+		return 0;
 
-	/* calculate x/y value (angle need to be converted into radian) */
-	if (mag > 1.0) mag = 1.0;
-	else if (mag < -1.0) mag = -1.0;
-	double val;
+	if (flip)
+		ret = -ret;
 
-	if(axis == 0) // x-axis
-		val = mag * sin((PI * ang)/180.0f);
-	else // y-axis
-		val = mag * cos((PI * ang)/180.0f);
+	if (ret < AXIS_MIN)
+		ret = AXIS_MIN;
+	else if (ret > AXIS_MAX)
+		ret = AXIS_MAX;
 
-	return (s16)(val * 128.0f);
+	return ret;
 }
 
+static const u32 _buttons[8] = {
+	// wiimote
+	WPAD_BUTTON_UP,
+	WPAD_BUTTON_DOWN,
+	WPAD_BUTTON_LEFT,
+	WPAD_BUTTON_RIGHT,
+	// classic
+	WPAD_CLASSIC_BUTTON_UP,
+	WPAD_CLASSIC_BUTTON_DOWN,
+	WPAD_CLASSIC_BUTTON_LEFT,
+	WPAD_CLASSIC_BUTTON_RIGHT
+};
+
 static void _HandleWiiJoystickUpdate(SDL_Joystick* joystick)
 {
-	u32 buttons, prev_buttons, changed;
-	u32 exp_type;
-	struct expansion_t exp;
+	u32 changed;
 	int i, axis;
 	joystick_hwdata *prev_state;
 	WPADData *data;
+	const u32 *buttons;
 
-	buttons = WPAD_ButtonsHeld(joystick->index);
-
-	if (WPAD_Probe(joystick->index, &exp_type) != 0)
-		exp_type = WPAD_EXP_NONE;
-
-	 data = WPAD_Data(joystick->index);
-	 WPAD_Expansion(joystick->index, &exp);
+	if (!WPAD_ReadPending(WPAD_CHAN_0, NULL))
+		return;
+	data = WPAD_Data(joystick->index);
+	changed = data->btns_d | data->btns_u;
+	prev_state = (joystick_hwdata*)joystick->hwdata;
 
-	prev_state = (joystick_hwdata *)joystick->hwdata;
-	prev_buttons = prev_state->wiimote.prev_buttons;
-	changed = buttons ^ prev_buttons;
+	if(data->exp.type == WPAD_EXP_CLASSIC) // classic controller
+		buttons = _buttons+4;
+	else
+		buttons = _buttons;
 
-	if(exp_type == WPAD_EXP_CLASSIC) // classic controller
+	if (changed & (buttons[0]|buttons[1]|buttons[2]|buttons[3]))
 	{
-		if(changed & (WPAD_CLASSIC_BUTTON_LEFT | WPAD_CLASSIC_BUTTON_RIGHT |
-			WPAD_CLASSIC_BUTTON_DOWN | WPAD_CLASSIC_BUTTON_UP))
-		{
-			int hat = SDL_HAT_CENTERED;
-			if(buttons & WPAD_CLASSIC_BUTTON_UP) hat |= SDL_HAT_UP;
-			if(buttons & WPAD_CLASSIC_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
-			if(buttons & WPAD_CLASSIC_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
-			if(buttons & WPAD_CLASSIC_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
-			SDL_PrivateJoystickHat(joystick, 0, hat);
-		}
-	}
-	else // wiimote
-	{
-		if(changed & (WPAD_BUTTON_LEFT | WPAD_BUTTON_RIGHT | WPAD_BUTTON_DOWN | WPAD_BUTTON_UP))
-		{
-			int hat = SDL_HAT_CENTERED;
-			if(buttons & WPAD_BUTTON_UP) hat |= SDL_HAT_LEFT;
-			if(buttons & WPAD_BUTTON_DOWN) hat |= SDL_HAT_RIGHT;
-			if(buttons & WPAD_BUTTON_LEFT) hat |= SDL_HAT_DOWN;
-			if(buttons & WPAD_BUTTON_RIGHT) hat |= SDL_HAT_UP;
-			SDL_PrivateJoystickHat(joystick, 0, hat);
-		}
+		int hat = SDL_HAT_CENTERED;
+		u32 pressed = data->btns_d | data->btns_h;
+
+		if (pressed & buttons[0]) hat |= SDL_HAT_UP;
+		if (pressed & buttons[1]) hat |= SDL_HAT_DOWN;
+		if (pressed & buttons[2]) hat |= SDL_HAT_LEFT;
+		if (pressed & buttons[3]) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
 	}
 
 	for(i = 0; i < (sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0])); i++)
 	{
-		if ( (exp_type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
-				(exp_type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i)) )
+		if ( (data->exp.type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+				(data->exp.type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i)) )
 			continue;
 
 		if (changed & sdl_buttons_wii[i])
 			SDL_PrivateJoystickButton(joystick, i,
-				(buttons & sdl_buttons_wii[i]) ? SDL_PRESSED : SDL_RELEASED);
+				(data->btns_d & sdl_buttons_wii[i]) ? SDL_PRESSED : SDL_RELEASED);
 	}
-	prev_state->wiimote.prev_buttons = buttons;
 
-	if(exp_type == WPAD_EXP_CLASSIC)
+	if(data->exp.type == WPAD_EXP_CLASSIC)
 	{
-		axis = WPAD_Stick(data, 0, 0);
+		if (prev_state->wiimote.exp != WPAD_EXP_CLASSIC)
+		{
+			prev_state->wiimote.classic_calibrated = 0;
+			prev_state->wiimote.classic_cal[0][0] = 5;  // left x min
+			prev_state->wiimote.classic_cal[0][2] = 59; // left x max
+			prev_state->wiimote.classic_cal[1][0] = 5; // left y min
+			prev_state->wiimote.classic_cal[1][2] = 59;  // left y max
+			prev_state->wiimote.classic_cal[2][0] = 5;  // right x min
+			prev_state->wiimote.classic_cal[2][2] = 27; // right x max
+			prev_state->wiimote.classic_cal[3][0] = 5; // right y min
+			prev_state->wiimote.classic_cal[3][2] = 27;  // right y max
+
+		}
+
+		// max/min checking
+		// left stick x
+		if (data->exp.classic.ljs.pos.x < prev_state->wiimote.classic_cal[0][0])
+			prev_state->wiimote.classic_cal[0][0] = data->exp.classic.ljs.pos.x;
+		else if (data->exp.classic.ljs.pos.x > prev_state->wiimote.classic_cal[0][2])
+			prev_state->wiimote.classic_cal[0][2] = data->exp.classic.ljs.pos.x;
+		// left stick y
+		if (data->exp.classic.ljs.pos.y < prev_state->wiimote.classic_cal[1][0])
+			prev_state->wiimote.classic_cal[1][0] = data->exp.classic.ljs.pos.y;
+		else if (data->exp.classic.ljs.pos.y > prev_state->wiimote.classic_cal[1][2])
+			prev_state->wiimote.classic_cal[1][2] = data->exp.classic.ljs.pos.y;
+		// right stick x
+		if (data->exp.classic.rjs.pos.x < prev_state->wiimote.classic_cal[2][0])
+			prev_state->wiimote.classic_cal[2][0] = data->exp.classic.rjs.pos.x;
+		else if (data->exp.classic.rjs.pos.x > prev_state->wiimote.classic_cal[2][2])
+			prev_state->wiimote.classic_cal[2][2] = data->exp.classic.rjs.pos.x;
+		// right stick y
+		if (data->exp.classic.rjs.pos.y < prev_state->wiimote.classic_cal[3][0])
+			prev_state->wiimote.classic_cal[3][0] = data->exp.classic.rjs.pos.y;
+		else if (data->exp.classic.rjs.pos.y > prev_state->wiimote.classic_cal[3][2])
+			prev_state->wiimote.classic_cal[3][2] = data->exp.classic.rjs.pos.y;
+
+		// calibrate center positions
+		if (prev_state->wiimote.classic_calibrated < 5)
+		{
+			prev_state->wiimote.classic_cal[0][1] = data->exp.classic.ljs.pos.x;
+			prev_state->wiimote.classic_cal[1][1] = data->exp.classic.ljs.pos.y;
+			prev_state->wiimote.classic_cal[2][1] = data->exp.classic.rjs.pos.x;
+			prev_state->wiimote.classic_cal[3][1] = data->exp.classic.rjs.pos.y;
+			// this is zero if the expansion hasn't finished initializing
+			if (data->exp.classic.ljs.max.x)
+				prev_state->wiimote.classic_calibrated++;
+		}
+
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.x, prev_state->wiimote.classic_cal[0][0],
+			prev_state->wiimote.classic_cal[0][1], prev_state->wiimote.classic_cal[0][2], 0);
 		if(prev_state->wiimote.classicL_stickX != axis)
 		{
-			s16 value;
-			if (axis >= 128) value = AXIS_MAX;
-			else if (axis <=-128) value = AXIS_MIN;
-			else value = axis << 8;
-			SDL_PrivateJoystickAxis(joystick, 0, value);
+			SDL_PrivateJoystickAxis(joystick, 0, axis);
 			prev_state->wiimote.classicL_stickX = axis;
 		}
-		axis = WPAD_Stick(data, 0, 1);
+		// y axes are reversed
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.y, prev_state->wiimote.classic_cal[1][0],
+			prev_state->wiimote.classic_cal[1][1], prev_state->wiimote.classic_cal[1][2], 1);
 		if(prev_state->wiimote.classicL_stickY != axis)
 		{
-			s16 value;
-			if (axis >= 128) value = AXIS_MAX;
-			else if (axis <=-128) value = AXIS_MIN;
-			else value = axis << 8;
-			SDL_PrivateJoystickAxis(joystick, 1, -value);
+			SDL_PrivateJoystickAxis(joystick, 1, axis);
 			prev_state->wiimote.classicL_stickY = axis;
 		}
-		axis = WPAD_Stick(data, 1, 0);
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.x, prev_state->wiimote.classic_cal[2][0],
+			prev_state->wiimote.classic_cal[2][1], prev_state->wiimote.classic_cal[2][2], 0);
 		if(prev_state->wiimote.classicR_stickX != axis)
 		{
-			SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+			SDL_PrivateJoystickAxis(joystick, 2, axis);
 			prev_state->wiimote.classicR_stickX = axis;
 		}
-		axis = WPAD_Stick(data, 1, 1);
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.y, prev_state->wiimote.classic_cal[3][0],
+			prev_state->wiimote.classic_cal[3][1], prev_state->wiimote.classic_cal[3][2], 1);
 		if(prev_state->wiimote.classicR_stickY != axis)
 		{
-			SDL_PrivateJoystickAxis(joystick, 3, -(axis << 8));
+			SDL_PrivateJoystickAxis(joystick, 3, axis);
 			prev_state->wiimote.classicR_stickY = axis;
 		}
-		axis = exp.classic.r_shoulder*255;
+		axis = data->exp.classic.r_shoulder;
 		if(prev_state->wiimote.classic_triggerR != axis)
 		{
-			SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+			SDL_PrivateJoystickAxis(joystick, 4, axis<<8);
 			prev_state->wiimote.classic_triggerR = axis;
 		}
-		axis = exp.classic.l_shoulder*255;
+		axis = data->exp.classic.l_shoulder;
 		if(prev_state->wiimote.classic_triggerL != axis)
 		{
-			SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+			SDL_PrivateJoystickAxis(joystick, 5, axis<<8);
 			prev_state->wiimote.classic_triggerL = axis;
 		}
 	}
-	else if(exp_type == WPAD_EXP_NUNCHUK)
+	else if(data->exp.type == WPAD_EXP_NUNCHUK)
 	{
-		axis = WPAD_Stick(data, 0, 0);
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.x, data->exp.nunchuk.js.min.x,
+			data->exp.nunchuk.js.center.x, data->exp.nunchuk.js.max.x, 0);
 		if(prev_state->wiimote.nunchuk_stickX != axis)
 		{
-			s16 value;
-			if (axis >= 128) value = AXIS_MAX;
-			else if (axis <=-128) value = AXIS_MIN;
-			else value = axis << 8;
-			SDL_PrivateJoystickAxis(joystick, 0, value);
+			SDL_PrivateJoystickAxis(joystick, 0, axis);
 			prev_state->wiimote.nunchuk_stickX = axis;
 		}
-		axis = WPAD_Stick(data, 0, 1);
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.y, data->exp.nunchuk.js.min.y,
+			data->exp.nunchuk.js.center.y, data->exp.nunchuk.js.max.y, 1);
 		if(prev_state->wiimote.nunchuk_stickY != axis)
 		{
-			s16 value;
-			if (axis >= 128) value = AXIS_MAX;
-			else if (axis <=-128) value = AXIS_MIN;
-			else value = axis << 8;
-			SDL_PrivateJoystickAxis(joystick, 1, -value);
+			SDL_PrivateJoystickAxis(joystick, 1, axis);
 			prev_state->wiimote.nunchuk_stickY = axis;
 		}
 	}
 
+	prev_state->wiimote.exp = data->exp.type;
+
 	axis = WPAD_Pitch(data);
 	if(prev_state->wiimote.wiimote_pitch != axis)
 	{
@@ -439,8 +464,9 @@ static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
 	int i;
 	int axis;
 	joystick_hwdata *prev_state;
+	int index = joystick->index - 4;
 
-	buttons = PAD_ButtonsHeld(joystick->index - 4);
+	buttons = PAD_ButtonsHeld(index);
 	prev_state = (joystick_hwdata *)joystick->hwdata;
 	prev_buttons = prev_state->gamecube.prev_buttons;
 	changed = buttons ^ prev_buttons;
@@ -462,45 +488,45 @@ static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
 				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
 	}
 	prev_state->gamecube.prev_buttons = buttons;
-	axis = PAD_StickX(joystick->index-4);
+	axis = PAD_StickX(index);
 	if(prev_state->gamecube.stickX != axis)
 	{
 		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
 		prev_state->gamecube.stickX = axis;
 	}
 
-	axis = PAD_StickY(joystick->index-4);
+	axis = PAD_StickY(index);
 	if(prev_state->gamecube.stickY != axis)
 	{
 		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
 		prev_state->gamecube.stickY = axis;
 	}
 
-	axis = PAD_SubStickX(joystick->index-4);
+	axis = PAD_SubStickX(index);
 	if(prev_state->gamecube.substickX != axis)
 	{
 		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
 		prev_state->gamecube.substickX = axis;
 	}
 
-	axis = PAD_SubStickY(joystick->index-4);
+	axis = PAD_SubStickY(index);
 	if(prev_state->gamecube.substickY != axis)
 	{
 		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
 		prev_state->gamecube.substickY = axis;
 	}
 
-	axis = PAD_TriggerL(joystick->index-4);
+	axis = PAD_TriggerL(index);
 	if(prev_state->gamecube.triggerL != axis)
 	{
-		SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
 		prev_state->gamecube.triggerL = axis;
 	}
 
-	axis = PAD_TriggerR(joystick->index-4);
+	axis = PAD_TriggerR(index);
 	if(prev_state->gamecube.triggerR != axis)
 	{
-		SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
 		prev_state->gamecube.triggerR = axis;
 	}
 }
@@ -516,7 +542,7 @@ void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
 	if(!joystick || !joystick->hwdata)
 		return;
 
-	WPAD_ScanPads();
+//	WPAD_ScanPads();
 	PAD_ScanPads();
 
 	switch(((joystick_hwdata*)(joystick->hwdata))->type)
@@ -528,7 +554,7 @@ void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
 		case 1:
 		if(__jspad_enabled)
 		_HandleGCJoystickUpdate(joystick);
-		break;
+		//break;
 		default:
 		break;
 	}
@@ -541,6 +567,7 @@ void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
 		return;
 
 	SDL_free(joystick->hwdata);
+	joystick->hwdata = NULL;
 }
 
 /* Function to perform any system-specific joystick related cleanup */
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
index a7b6c3af4..1a8935908 100644
--- a/src/main/wii/SDL_wii_main.c
+++ b/src/main/wii/SDL_wii_main.c
@@ -9,6 +9,7 @@
 #include "../../video/wii/SDL_wiivideo.h"
 
 /* OGC includes */
+#include <fat.h>
 #include <ogcsys.h>
 #include <wiiuse/wpad.h>
 #include <ogc/usbmouse.h>
@@ -74,6 +75,7 @@ int main(int argc, char *argv[])
 	MOUSE_Init();
 	KEYBOARD_Init(NULL);
 #endif
+    fatInitDefault();
 	/* Call the user's main function */
 	return(SDL_main(argc, argv));
 }
diff --git a/src/video/wii/SDL_wiievents.c b/src/video/wii/SDL_wiievents.c
index 06ecec6e5..720b59532 100644
--- a/src/video/wii/SDL_wiievents.c
+++ b/src/video/wii/SDL_wiievents.c
@@ -29,116 +29,98 @@
 #include <unistd.h>
 #include <ogc/usbmouse.h>
 #include <wiikeyboard/keyboard.h>
+#include <ogc/pad.h>
 
 #include "SDL_wiivideo.h"
 #include "SDL_wiievents_c.h"
 
-static Uint8 lastButtonStateA = SDL_RELEASED;
-static Uint8 lastButtonStateB = SDL_RELEASED;
-
 static SDLKey keymap[232];
 
-static s32 stat;
-static s32 mstat;
-static WPADData *wd;
-static int lastx = 0, lasty = 0;
-
-static keyboard_event ke;
-static mouse_event me;
-
 static int posted;
 
 extern bool TerminateRequested;
 extern void Terminate();
+extern int vresx, vresy;
 
 void PumpEvents()
 {
+	s32 stat;
 #ifdef HW_RVL
+	keyboard_event ke;
+	mouse_event me;
+
 	if (TerminateRequested) Terminate();
 #endif
-	wd = WPAD_Data(0);
-	stat = KEYBOARD_GetEvent(&ke);
-	mstat = MOUSE_GetEvent(&me);
-
-	if (wd->ir.valid)
-	{
-		int newx = wd->ir.x;
-		int newy = wd->ir.y;
-		int diffx = newx - lastx;
-		int diffy = newy - lasty;
-		lastx = newx;
-		lasty = newy;
-
-		posted += SDL_PrivateMouseMotion(0, 1, diffx, diffy);
-
-		Uint8 stateA = SDL_RELEASED;
-		Uint8 stateB = SDL_RELEASED;
 
-		if (wd->btns_h & WPAD_BUTTON_A)
-		{
-			stateA = SDL_PRESSED;
-		}
-		if (wd->btns_h & WPAD_BUTTON_B)
-		{
-			stateB = SDL_PRESSED;
-		}
-		if (stateA != lastButtonStateA)
-		{
-			lastButtonStateA = stateA;
-			posted += SDL_PrivateMouseButton(stateA, SDL_BUTTON_LEFT, 0, 0);
-		}
-		if (stateB != lastButtonStateB)
-		{
-			lastButtonStateB = stateB;
-			posted += SDL_PrivateMouseButton(stateB, SDL_BUTTON_RIGHT, 0, 0);
-		}
+	// this will only work if Joystick 0 has been opened and has been polled
+	WPADData *wd = WPAD_Data(WPAD_CHAN_0);
+	if (wd && wd->exp.type != WPAD_EXP_CLASSIC && wd->ir.valid) {
+		// use SDL_BUTTON_X2 to signal that this is the wiimote acting as a mouse
+		Uint8 Buttons = SDL_GetMouseState(NULL, NULL)|SDL_BUTTON_X2MASK;
+		if (wd->ir.x < vresx/8)
+			wd->ir.x = vresx/8;
+		else if (wd->ir.x > (vresx + vresx/8))
+			wd->ir.x = vresx + vresx/8;
+		if (wd->ir.y < vresy/8)
+			wd->ir.y = vresy/8;
+		else if (wd->ir.y > (vresy + vresy/8))
+			wd->ir.y = vresy + vresy/8;
+		posted += SDL_PrivateMouseMotion(Buttons, 0, wd->ir.x - vresx/8, wd->ir.y - vresy/8);
+		// most apps will ignore this (hopefully)
+		posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_X2, 0, 0);
+		wd->ir.valid = 0;
 	}
 
+	stat = KEYBOARD_GetEvent(&ke);
 	if (stat && (ke.type == KEYBOARD_RELEASED || ke.type == KEYBOARD_PRESSED))
 	{
 		SDL_keysym keysym;
 		memset(&keysym, 0, sizeof(keysym));
-		Uint8 keystate = (ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED
-				: SDL_RELEASED;
+		Uint8 keystate = (ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED : SDL_RELEASED;
 		keysym.sym = keymap[ke.keycode];
+		keysym.unicode = ke.symbol;
 		keysym.mod = 0;
 		posted += SDL_PrivateKeyboard(keystate, &keysym);
 	}
 
-	if (mstat)
+	stat = MOUSE_GetEvent(&me);
+	if (stat)
 	{
-		posted += SDL_PrivateMouseMotion(0, 1, me.rx, me.ry);
-
 		u8 button = me.button;
+		Uint8 mouse_state = SDL_GetMouseState(NULL, NULL);
+
+		posted += SDL_PrivateMouseMotion(0, 1, me.rx*2, me.ry*2);
 
-		if (button & 0x1)
-		{
-			if (!(SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(1)))
-			{
-				posted += SDL_PrivateMouseButton(SDL_PRESSED, 1, 0, 0);
-			}
+		if (button & 0x1) {
+			if (!(mouse_state & SDL_BUTTON_LMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_LEFT, 0, 0);
 		}
-		else
-		{
-			if ((SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(1)))
-			{
-				posted += SDL_PrivateMouseButton(SDL_RELEASED, 1, 0, 0);
-			}
+		else if (mouse_state & SDL_BUTTON_LMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_LEFT, 0, 0);
+
+		if (button & 0x2) {
+			if (!(mouse_state & SDL_BUTTON_RMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_RIGHT, 0, 0);
 		}
+		else if (mouse_state & SDL_BUTTON_RMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_RIGHT, 0, 0);
 
-		if (button & 0x2)
-		{
-			if (!(SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(3)))
-			{
-				posted += SDL_PrivateMouseButton(SDL_PRESSED, 3, 0, 0);
-			}
+		if (button & 0x4) {
+			if (!(mouse_state & SDL_BUTTON_MMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_MIDDLE, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_MMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_MIDDLE, 0, 0);
+
+		// mouse wheel actions are single events (rz==1(up) or rz==-1(down))
+		// send SDL_PRESSED immediately followed by SDL_RELEASED
+		if (me.rz > 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
 		}
-		else
-		{
-			if ((SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(3)))
-			{
-				posted += SDL_PrivateMouseButton(SDL_RELEASED, 3, 0, 0);
-			}
+		else if (me.rz < 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
 		}
 	}
 }
diff --git a/src/video/wii/SDL_wiivideo.c b/src/video/wii/SDL_wiivideo.c
index 2e8a493bc..ec3bc2fd0 100644
--- a/src/video/wii/SDL_wiivideo.c
+++ b/src/video/wii/SDL_wiivideo.c
@@ -33,20 +33,21 @@
 #include <gccore.h>
 #include <ogcsys.h>
 #include <malloc.h>
-#include <ogc/texconv.h>
 #include <wiiuse/wpad.h>
 #include "SDL_wiivideo.h"
 #include "SDL_wiievents_c.h"
+#include <ogc/machine/processor.h>
 
 static const char	WIIVID_DRIVER_NAME[] = "wii";
 static lwp_t videothread = LWP_THREAD_NULL;
-static SDL_mutex *videomutex = 0;
+static SDL_mutex *videomutex = NULL;
 static SDL_cond *videocond = NULL;
+static WiiVideo *current = NULL;
+
+int vresx=0, vresy=0;
 
 /*** SDL ***/
-static SDL_Rect mode_320;
-static SDL_Rect mode_640;
-static SDL_Rect mode_848;
+static SDL_Rect mode_320, mode_640, mode_848;
 
 static SDL_Rect* modes_descending[] =
 {
@@ -59,20 +60,16 @@ static SDL_Rect* modes_descending[] =
 /*** 2D Video ***/
 #define HASPECT 			320
 #define VASPECT 			240
-#define TEXTUREMEM_SIZE 	(640*480*4)
 
-unsigned int *xfb[2] = { NULL, NULL }; // Double buffered
-int whichfb = 0; // Switch
+unsigned char *xfb = NULL;
 GXRModeObj* vmode = 0;
-u8 * screenTex = NULL; // screen capture
 static int quit_flip_thread = 0;
-static unsigned char texturemem[TEXTUREMEM_SIZE] __attribute__((aligned(32))); // GX texture
-static unsigned char textureconvert[TEXTUREMEM_SIZE] __attribute__((aligned(32))); // 565 mem
+static GXTexObj texobj_a, texobj_b;
+static GXTlutObj texpalette_a, texpalette_b;
 
 /*** GX ***/
 #define DEFAULT_FIFO_SIZE 256 * 1024
 static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
-static GXTexObj texobj;
 
 /* New texture based scaler */
 typedef struct tagcamera
@@ -99,6 +96,12 @@ static s16 square[] ATTRIBUTE_ALIGN (32) =
 	-HASPECT, -VASPECT, 0	// 3
 };
 
+static const f32 tex_pos[] ATTRIBUTE_ALIGN(32) = {
+	0.0, 0.0,
+	1.0, 0.0,
+	1.0, 1.0,
+	0.0, 1.0,
+};
 
 static camera cam = {
 	{0.0F, 0.0F, 0.0F},
@@ -114,21 +117,19 @@ static int currentheight;
 static int currentbpp;
 
 static void
-draw_init ()
+draw_init(void *palette, void *tex)
 {
 	Mtx m, mv, view;
 
 	GX_ClearVtxDesc ();
 	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
-	GX_SetVtxDesc (GX_VA_CLR0, GX_INDEX8);
-	GX_SetVtxDesc (GX_VA_TEX0, GX_DIRECT);
+	GX_SetVtxDesc (GX_VA_TEX0, GX_INDEX8);
 
 	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
-	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
 	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
 
 	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
-
+	GX_SetArray (GX_VA_TEX0, (void*)tex_pos, 2 * sizeof (f32));
 	GX_SetNumTexGens (1);
 	GX_SetNumChans (0);
 
@@ -137,61 +138,66 @@ draw_init ()
 	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
 	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
 
-	memset (&view, 0, sizeof (Mtx));
+	memset(&view, 0, sizeof (Mtx));
 	guLookAt(view, &cam.pos, &cam.up, &cam.view);
 	guMtxIdentity(m);
 	guMtxTransApply(m, m, 0, 0, -100);
 	guMtxConcat(view, m, mv);
-	GX_LoadPosMtxImm (view, GX_PNMTX0);
+	GX_LoadPosMtxImm(mv, GX_PNMTX0);
 
 	GX_InvVtxCache ();	// update vertex cache
 
-	// initialize the texture obj we are going to use
-	if (currentbpp == 8 || currentbpp == 16)
-		GX_InitTexObj (&texobj, texturemem, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
+	if (currentbpp == 8) {
+		GX_InitTlutObj(&texpalette_a, palette, GX_TL_IA8, 256);
+		GX_InitTlutObj(&texpalette_b, (Uint16*)palette+256, GX_TL_IA8, 256);
+		DCStoreRange(palette, sizeof(512*sizeof(Uint16)));
+		GX_LoadTlut(&texpalette_a, GX_TLUT0);
+		GX_LoadTlut(&texpalette_b, GX_TLUT1);
+
+		GX_InitTexObjCI(&texobj_a, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+		GX_InitTexObjCI(&texobj_b, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+		GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+		// Setup TEV to combine Red+Green and Blue paletted images
+		GX_SetTevColor(GX_TEVREG0, (GXColor){255, 255, 0, 0});
+		GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		// first stage = red and green
+		GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+		GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+		// second stage = add blue (and opaque alpha)
+		GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+		GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+		GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+		GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+		GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+		GX_SetNumTevStages(2);
+	}
+	else if (currentbpp == 16)
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
 	else
-		GX_InitTexObj (&texobj, texturemem, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
 
-	GX_LoadTexObj (&texobj, GX_TEXMAP0);	// load texture object so its ready to use
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);	// load texture object so its ready to use
 }
 
 static inline void
-draw_vert (u8 pos, u8 c, f32 s, f32 t)
+draw_vert (u8 index)
 {
-	GX_Position1x8 (pos);
-	GX_Color1x8 (c);
-	GX_TexCoord2f32 (s, t);
+	GX_Position1x8 (index);
+	GX_TexCoord1x8 (index);
 }
 
 static inline void
 draw_square ()
 {
-	GX_Begin (GX_QUADS, GX_VTXFMT0, 4);
-	draw_vert (0, 0, 0.0, 0.0);
-	draw_vert (1, 0, 1.0, 0.0);
-	draw_vert (2, 0, 1.0, 1.0);
-	draw_vert (3, 0, 0.0, 1.0);
-	GX_End ();
-}
-
-/****************************************************************************
- * TakeScreenshot
- *
- * Copies the current screen into a GX texture
- ***************************************************************************/
-
-static void TakeScreenshot()
-{
-	int texSize = vmode->fbWidth * vmode->efbHeight * 4;
-
-	if(screenTex) free(screenTex);
-	screenTex = (u8 *)memalign(32, texSize);
-	if(screenTex == NULL) return;
-	GX_SetTexCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
-	GX_SetTexCopyDst(vmode->fbWidth, vmode->efbHeight, GX_TF_RGBA8, GX_FALSE);
-	GX_CopyTex(screenTex, GX_FALSE);
-	GX_PixModeSync();
-	DCFlushRange(screenTex, texSize);
+	GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+	draw_vert(0);
+	draw_vert(1);
+	draw_vert(2);
+	draw_vert(3);
+	GX_End();
 }
 
 static void * flip_thread (void *arg)
@@ -231,36 +237,67 @@ SetupGX()
 	Mtx44 p;
 	int df = 1; // deflicker on/off
 
+	GX_SetCurrentGXThread();
 	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
 	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
 	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
 
-	GX_SetDispCopySrc (0, 0, vmode->fbWidth, vmode->efbHeight);
-	GX_SetDispCopyDst (vmode->fbWidth, vmode->xfbHeight);
+	GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
 	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
 
 	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
 	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
 	GX_SetDispCopyGamma (GX_GM_1_0);
 	GX_SetCullMode (GX_CULL_NONE);
-	GX_SetBlendMode(GX_BM_BLEND,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
+	GX_SetBlendMode(GX_BM_NONE,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
 
-	GX_SetZMode (GX_TRUE, GX_LEQUAL, GX_TRUE);
+	GX_SetZMode (GX_FALSE, GX_LEQUAL, GX_TRUE);
 	GX_SetColorUpdate (GX_TRUE);
-	GX_SetNumChans(1);
+	GX_SetAlphaUpdate(GX_FALSE);
 
-	guOrtho(p, 480/2, -(480/2), -(640/2), 640/2, 100, 1000); // matrix, t, b, l, r, n, f
+	guOrtho(p, VASPECT, -VASPECT, -HASPECT, HASPECT, 100, 1000); // matrix, t, b, l, r, n, f
 	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
+	GX_Flush();
 }
 
 static void
-StartVideoThread()
+StartVideoThread(void *args)
 {
 	if(videothread == LWP_THREAD_NULL)
 	{
 		quit_flip_thread = 0;
-		LWP_CreateThread (&videothread, flip_thread, NULL, NULL, 0, 68);
+		LWP_CreateThread(&videothread, flip_thread, args, NULL, 0, 68);
+	}
+}
+
+void WII_VideoStart(WiiVideo *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
 	}
+
+	SetupGX();
+	draw_init(private->palette, private->texturemem);
+	StartVideoThread(&private->texturemem);
+	WPAD_SetVRes(WPAD_CHAN_0, vresx+vresx/4, vresy+vresy/4);
+	current = private;
+}
+
+void WII_VideoStop()
+{
+	if(videothread == LWP_THREAD_NULL)
+		return;
+
+	SDL_LockMutex(videomutex);
+	quit_flip_thread = 1;
+	SDL_CondSignal(videocond);
+	SDL_UnlockMutex(videomutex);
+
+	LWP_JoinThread(videothread, NULL);
+	videothread = LWP_THREAD_NULL;
 }
 
 static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
@@ -278,12 +315,13 @@ static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
 	vformat->BytesPerPixel	= 2;
 
 	this->hidden->buffer = NULL;
+	this->hidden->texturemem = NULL;
 	this->hidden->width = 0;
 	this->hidden->height = 0;
 	this->hidden->pitch = 0;
 
 	/* We're done! */
-	return(0);
+	return 0;
 }
 
 static SDL_Rect **WII_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
@@ -327,33 +365,51 @@ static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
 
 	bytes_per_pixel = bpp / 8;
 
-	// Free any existing buffer.
-	if (this->hidden->buffer)
-	{
-		free(this->hidden->buffer);
-		this->hidden->buffer = NULL;
-	}
+	WII_VideoStop();
+
+	free(this->hidden->buffer);
+	free(this->hidden->texturemem);
 
 	// Allocate the new buffer.
 	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
 	if (!this->hidden->buffer )
 	{
+		this->hidden->texturemem = NULL;
 		SDL_SetError("Couldn't allocate buffer for requested mode");
 		return(NULL);
 	}
 
+	// Allocate texture memory
+	if (bytes_per_pixel > 2)
+		this->hidden->texturemem_size = width * height * 4;
+	else
+		this->hidden->texturemem_size = width * height * bytes_per_pixel;
+
+	this->hidden->texturemem = memalign(32, this->hidden->texturemem_size);
+	if (this->hidden->texturemem == NULL)
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		SDL_SetError("Couldn't allocate memory for texture");
+		return NULL;
+	}
+
 	// Allocate the new pixel format for the screen
 	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
 	{
 		free(this->hidden->buffer);
 		this->hidden->buffer = NULL;
+		free(this->hidden->texturemem);
+		this->hidden->texturemem = NULL;
 
+		SDL_UnlockMutex(videomutex);
 		SDL_SetError("Couldn't allocate new pixel format for requested mode");
-		return(NULL);
+		return NULL;
 	}
 
 	// Clear the buffer
 	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
+	SDL_memset(this->hidden->texturemem, 0, this->hidden->texturemem_size);
 
 	// Set up the new mode framebuffer
 	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME);
@@ -367,16 +423,17 @@ static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
 	/* Set the hidden data */
 	this->hidden->width = current->w;
 	this->hidden->height = current->h;
-	this->hidden->pitch = current->pitch;
+	this->hidden->pitch = current->w * (bytes_per_pixel > 2 ? 4 : bytes_per_pixel);
 
 	currentwidth = current->w;
 	currentheight = current->h;
 	currentbpp = bpp;
-	WPAD_SetVRes(WPAD_CHAN_ALL, currentwidth*1.5, currentheight*1.5);
-	draw_init();
-	StartVideoThread();
-	/* We're done */
-	return(current);
+	vresx = currentwidth;
+	vresy = currentheight;
+
+	WII_VideoStart(this->hidden);
+
+	return current;
 }
 
 /* We don't actually allow hardware surfaces other than the main one */
@@ -402,45 +459,54 @@ static void WII_UnlockHWSurface(_THIS, SDL_Surface *surface)
 
 static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
 {
-	u8 *truc = (u8*) texturemem;
+	u8 *truc = this->hidden->texturemem;
 	int width = this->hidden->width;
 	u32 offset;
 
-	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + (((y % 4 << 2) + x % 4) << 1);
+	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + ((((y & 3) << 2) + (x & 3)) << 1);
 
-	*(truc + offset) = color & 0xFF;
-	*(truc + offset + 1) = (color >> 24) & 0xFF;
-	*(truc + offset + 32) = (color >> 16) & 0xFF;
-	*(truc + offset + 33) = (color >> 8) & 0xFF;
+	*(truc + offset) = color;
+	*(truc + offset + 1) = color >> 24;
+	*(truc + offset + 32) = color >> 16;
+	*(truc + offset + 33) = color >> 8;
 }
 
 static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
 {
-	u8 *truc = (u8*) texturemem;
+	u8 *truc = this->hidden->texturemem;
 	int width = this->hidden->width;
 	u32 offset;
 
-	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + (((y % 4 << 2) + x % 4) << 1);
+	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color >> 8;
+	*(truc + offset + 1) = color;
+}
+
+static inline void Set_PalPixel(_THIS, int x, int y, u8 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->pitch;
+	u32 offset;
+
+	offset = ((y & ~3) * width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
 
-	*(truc + offset) = (color >> 8) & 0xFF;
-	*(truc + offset + 1) = color & 0xFF;
+	truc[offset] = color;
 }
 
 static void UpdateRect_8(_THIS, SDL_Rect *rect)
 {
 	u8 *src;
-	u8 *ptr;
-	u16 color;
+	u8 color;
 	int i, j;
-	Uint16 *palette = this->hidden->palette;
+
 	for (i = 0; i < rect->h; i++)
 	{
-		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + (rect->x));
+		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + rect->x);
 		for (j = 0; j < rect->w; j++)
 		{
-			ptr = src + j;
-			color = palette[*ptr];
-			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+			color = src[j];
+			Set_PalPixel(this, rect->x + j, rect->y + i, color);
 		}
 	}
 }
@@ -499,10 +565,40 @@ static void UpdateRect_32(_THIS, SDL_Rect *rect)
 	}
 }
 
+static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
+{
+	int h, w;
+	long long int *dst = (long long int *) this->hidden->texturemem;
+	long long int *src1 = (long long int *) this->hidden->buffer;
+	long long int *src2 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 1));
+	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
+	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
+	int rowpitch = (this->hidden->pitch >> 3) * 3;
+
+	SDL_mutexP(videomutex);
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < this->hidden->pitch; w += 8)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 = src4;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+	}
+	SDL_CondSignal(videocond);
+	SDL_mutexV(videomutex);
+}
+
 static void WII_UpdateRect(_THIS, SDL_Rect *rect)
 {
 	const SDL_Surface* const screen = this->screen;
-	SDL_mutexP(videomutex);
+
 	switch(screen->format->BytesPerPixel) {
 	case 1:
 		UpdateRect_8(this, rect);
@@ -520,7 +616,6 @@ static void WII_UpdateRect(_THIS, SDL_Rect *rect)
 		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
 		break;
 	}
-	SDL_mutexV(videomutex);
 }
 
 static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
@@ -532,127 +627,22 @@ static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
 
 	for (i = 0; i < numrects; i++)
 	{
-		WII_UpdateRect(this, &rects[i]);
-	}
-
-	SDL_CondSignal(videocond);
-}
-
-static void flipHWSurface_8_16(_THIS, SDL_Surface *surface)
-{
-	int new_pitch = this->hidden->width * 2;
-	long long int *dst = (long long int *) texturemem;
-	long long int *src1 = (long long int *) textureconvert;
-	long long int *src2 = (long long int *) (textureconvert + new_pitch);
-	long long int *src3 = (long long int *) (textureconvert + (new_pitch * 2));
-	long long int *src4 = (long long int *) (textureconvert + (new_pitch * 3));
-	int rowpitch = (new_pitch >> 3) * 3;
-	int rowadjust = (new_pitch % 8) * 4;
-	Uint16 *palette = this->hidden->palette;
-	char *ra = NULL;
-	int h, w;
-
-	// crude convert
-	Uint16 * ptr_cv = (Uint16 *) textureconvert;
-	Uint8 *ptr = (Uint8 *)this->hidden->buffer;
-
-	for (h = 0; h < this->hidden->height; h++)
-	{
-		for (w = 0; w < this->hidden->width; w++)
-		{
-			Uint16 v = palette[*ptr];
-
-			*ptr_cv++ = v;
-			ptr++;
-		}
-	}
-
-	// same as 16bit
-	for (h = 0; h < this->hidden->height; h += 4)
-	{
-		for (w = 0; w < (this->hidden->width >> 2); w++)
-		{
-			*dst++ = *src1++;
-			*dst++ = *src2++;
-			*dst++ = *src3++;
-			*dst++ = *src4++;
-		}
-
-		src1 += rowpitch;
-		src2 += rowpitch;
-		src3 += rowpitch;
-		src4 += rowpitch;
-
-		if ( rowadjust )
-		{
-			ra = (char *)src1;
-			src1 = (long long int *)(ra + rowadjust);
-			ra = (char *)src2;
-			src2 = (long long int *)(ra + rowadjust);
-			ra = (char *)src3;
-			src3 = (long long int *)(ra + rowadjust);
-			ra = (char *)src4;
-			src4 = (long long int *)(ra + rowadjust);
-		}
-	}
-}
-
-static void flipHWSurface_16_16(_THIS, SDL_Surface *surface)
-{
-	int h, w;
-	long long int *dst = (long long int *) texturemem;
-	long long int *src1 = (long long int *) this->hidden->buffer;
-	long long int *src2 = (long long int *) (this->hidden->buffer + this->hidden->pitch);
-	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
-	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
-	int rowpitch = (this->hidden->pitch >> 3) * 3;
-	int rowadjust = (this->hidden->pitch % 8) * 4;
-	char *ra = NULL;
-
-	SDL_mutexP(videomutex);
-
-	for (h = 0; h < this->hidden->height; h += 4)
-	{
-		for (w = 0; w < this->hidden->width; w += 4)
-		{
-			*dst++ = *src1++;
-			*dst++ = *src2++;
-			*dst++ = *src3++;
-			*dst++ = *src4++;
-		}
-
-		src1 += rowpitch;
-		src2 += rowpitch;
-		src3 += rowpitch;
-		src4 += rowpitch;
-
-		if ( rowadjust )
-		{
-			ra = (char *)src1;
-			src1 = (long long int *)(ra + rowadjust);
-			ra = (char *)src2;
-			src2 = (long long int *)(ra + rowadjust);
-			ra = (char *)src3;
-			src3 = (long long int *)(ra + rowadjust);
-			ra = (char *)src4;
-			src4 = (long long int *)(ra + rowadjust);
-		}
+		WII_UpdateRect(this, rects+i);
 	}
 
 	SDL_CondSignal(videocond);
-	SDL_mutexV(videomutex);
 }
 
 static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
 {
 	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	WII_UpdateRect(this, &screen_rect);
+	WII_UpdateRects(this, 1, &screen_rect);
 }
 
 static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
 {
 	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	WII_UpdateRect(this, &screen_rect);
+	WII_UpdateRects(this, 1, &screen_rect);
 }
 
 static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
@@ -660,9 +650,8 @@ static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
 	switch(surface->format->BytesPerPixel)
 	{
 		case 1:
-			flipHWSurface_8_16(this, surface);
-			break;
 		case 2:
+			// 8 and 16 bit use the same tile format
 			flipHWSurface_16_16(this, surface);
 			break;
 		case 3:
@@ -674,7 +663,7 @@ static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
 		default:
 			return -1;
 	}
-	return 1;
+	return 0;
 }
 
 static int WII_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
@@ -683,17 +672,24 @@ static int WII_SetColors(_THIS, int first_color, int color_count, SDL_Color *col
 	Uint16* const palette = this->hidden->palette;
 	int     component;
 
-	/* Build the RGB565 palette. */
-	for (component = first_color; component != last_color; ++component)
-	{
-		const SDL_Color* const in = &colors[component - first_color];
-		const unsigned int r    = (in->r >> 3) & 0x1f;
-		const unsigned int g    = (in->g >> 2) & 0x3f;
-		const unsigned int b    = (in->b >> 3) & 0x1f;
+	SDL_LockMutex(videomutex);
 
-		palette[component] = (r << 11) | (g << 5) | b;
+	/* Build the RGB24 palette. */
+	for (component = first_color; component != last_color; ++component, ++colors)
+	{
+		palette[component] = (colors->g << 8) | colors->r;
+		palette[component+256] = colors->b;
 	}
 
+	DCStoreRangeNoSync(palette+first_color, color_count*sizeof(Uint16));
+	DCStoreRange(palette+first_color+256, color_count*sizeof(Uint16));
+	GX_LoadTlut(&texpalette_a, GX_TLUT0);
+	GX_LoadTlut(&texpalette_b, GX_TLUT1);
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);
+	GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+	SDL_UnlockMutex(videomutex);
+
 	return(1);
 }
 
@@ -703,13 +699,20 @@ static void WII_VideoQuit(_THIS)
 	GX_AbortFrame();
 	GX_Flush();
 
+	current = NULL;
+
 	VIDEO_SetBlack(TRUE);
 	VIDEO_Flush();
+
+	free(this->hidden->buffer);
+	this->hidden->buffer = NULL;
+	free(this->hidden->texturemem);
+	this->hidden->texturemem = NULL;
 }
 
 static void WII_DeleteDevice(SDL_VideoDevice *device)
 {
-	SDL_free(device->hidden);
+	free(device->hidden);
 	SDL_free(device);
 
 	SDL_DestroyCond(videocond);
@@ -727,7 +730,7 @@ static SDL_VideoDevice *WII_CreateDevice(int devindex)
 	if ( device ) {
 		SDL_memset(device, 0, (sizeof *device));
 		device->hidden = (struct SDL_PrivateVideoData *)
-			SDL_malloc((sizeof *device->hidden));
+			memalign(32, sizeof(struct SDL_PrivateVideoData));
 	}
 	if ( (device == NULL) || (device->hidden == NULL) ) {
 		SDL_OutOfMemory();
@@ -745,29 +748,21 @@ static SDL_VideoDevice *WII_CreateDevice(int devindex)
 	device->VideoInit = WII_VideoInit;
 	device->ListModes = WII_ListModes;
 	device->SetVideoMode = WII_SetVideoMode;
-	device->CreateYUVOverlay = NULL;
 	device->SetColors = WII_SetColors;
 	device->UpdateRects = WII_UpdateRects;
 	device->VideoQuit = WII_VideoQuit;
 	device->AllocHWSurface = WII_AllocHWSurface;
-	device->CheckHWBlit = NULL;
-	device->FillHWRect = NULL;
-	device->SetHWColorKey = NULL;
-	device->SetHWAlpha = NULL;
 	device->LockHWSurface = WII_LockHWSurface;
 	device->UnlockHWSurface = WII_UnlockHWSurface;
 	device->FlipHWSurface = WII_FlipHWSurface;
 	device->FreeHWSurface = WII_FreeHWSurface;
-	device->SetCaption = NULL;
-	device->SetIcon = NULL;
-	device->IconifyWindow = NULL;
-	device->GrabInput = NULL;
-	device->GetWMInfo = NULL;
 	device->InitOSKeymap = WII_InitOSKeymap;
 	device->PumpEvents = WII_PumpEvents;
+	device->input_grab = SDL_GRAB_ON;
 
 	device->free = WII_DeleteDevice;
 
+	WII_InitVideoSystem();
 	return device;
 }
 
@@ -789,88 +784,57 @@ WII_InitVideoSystem()
 	vmode = VIDEO_GetPreferredMode(NULL);
 
 	/* Set up the video system with the chosen mode */
+	if (vmode == &TVPal528IntDf)
+		vmode = &TVPal576IntDfScale;
+
 	VIDEO_Configure(vmode);
 
-	// Allocate the video buffers
-	xfb[0] = (u32 *) SYS_AllocateFramebuffer (vmode);
-	xfb[1] = (u32 *) SYS_AllocateFramebuffer (vmode);
-	DCInvalidateRange(xfb[0], VIDEO_GetFrameBufferSize(vmode));
-	DCInvalidateRange(xfb[1], VIDEO_GetFrameBufferSize(vmode));
-	xfb[0] = (u32 *) MEM_K0_TO_K1 (xfb[0]);
-	xfb[1] = (u32 *) MEM_K0_TO_K1 (xfb[1]);
+	// Allocate the video buffer
+	if (xfb) free(MEM_K1_TO_K0(xfb));
+	xfb = (unsigned char*) MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
 
-	VIDEO_ClearFrameBuffer(vmode, xfb[0], COLOR_BLACK);
-	VIDEO_ClearFrameBuffer(vmode, xfb[1], COLOR_BLACK);
-	VIDEO_SetNextFramebuffer (xfb[0]);
+	VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+	VIDEO_SetNextFramebuffer(xfb);
 
 	// Show the screen.
 	VIDEO_SetBlack(FALSE);
 	VIDEO_Flush();
-	VIDEO_WaitVSync();
-	if (vmode->viTVMode & VI_NON_INTERLACE)
-			VIDEO_WaitVSync();
-		else
-			while (VIDEO_GetNextField())
-				VIDEO_WaitVSync();
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
 
-	CON_Init(xfb[0],20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
+	//CON_Init(xfb,20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
 
 	/*** Clear out FIFO area ***/
-	memset (&gp_fifo, 0, DEFAULT_FIFO_SIZE);
+	memset(&gp_fifo, 0, DEFAULT_FIFO_SIZE);
 
 	/*** Initialise GX ***/
-	GX_Init (&gp_fifo, DEFAULT_FIFO_SIZE);
+	GX_Init(&gp_fifo, DEFAULT_FIFO_SIZE);
 
 	GXColor background = { 0, 0, 0, 0xff };
-	GX_SetCopyClear (background, 0x00ffffff);
+	GX_SetCopyClear (background, GX_MAX_Z24);
 
 	SetupGX();
 }
 
 void WII_SetWidescreen(int wide)
 {
-	if(wide)
-	{
-		vmode->viWidth = 678;
-		vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - 678) / 2;
+	int width;
+	if(wide) {
+		width = 678;
 	}
 	else
-	{
-		vmode->viWidth = 640;
-		vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - 640) / 2;
-	}
-	VIDEO_Configure (vmode);
-	VIDEO_Flush();
-	
-	VIDEO_WaitVSync ();
-		
-	if (vmode->viTVMode & VI_NON_INTERLACE)
-		VIDEO_WaitVSync();
-	else
-		while (VIDEO_GetNextField())
-			VIDEO_WaitVSync();
-}
+		width = 640;
 
-void WII_VideoStart()
-{
-	SetupGX();
-	draw_init();
-	StartVideoThread();
-	WPAD_SetVRes(WPAD_CHAN_ALL, currentwidth*2, currentheight*2);
-}
+	vmode->viWidth = width;
+	vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - width) / 2;
 
-void WII_VideoStop()
-{
-	if(videothread == LWP_THREAD_NULL)
-		return;
+	VIDEO_Configure (vmode);
 
-	SDL_LockMutex(videomutex);
-	quit_flip_thread = 1;
-	SDL_CondSignal(videocond);
-	SDL_UnlockMutex(videomutex);
+	if (xfb)
+		VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
 
-	LWP_JoinThread(videothread, NULL);
-	videothread = LWP_THREAD_NULL;
+	VIDEO_Flush();
+
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
 }
 
 void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
@@ -880,4 +844,5 @@ void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
 	square[4] = square[1]  =  yscale - yshift;
 	square[7] = square[10] = -yscale - yshift;
 	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
+	GX_InvVtxCache();
 }
diff --git a/src/video/wii/SDL_wiivideo.h b/src/video/wii/SDL_wiivideo.h
index d893706ac..c0331f076 100644
--- a/src/video/wii/SDL_wiivideo.h
+++ b/src/video/wii/SDL_wiivideo.h
@@ -30,22 +30,28 @@
 #include <ogc/gx_struct.h>
 
 /* Hidden "this" pointer for the video functions */
-#define _THIS	SDL_VideoDevice *this
+#define _THIS   SDL_VideoDevice *this
 
 /* Private display data */
-struct SDL_PrivateVideoData
+typedef struct SDL_PrivateVideoData
 {
-	Uint8*					buffer;
-	int						width;
-	int						height;
-	int						pitch;
+    // 2x256x16bit palettes = 1x256x24(32)bit palette
+    // first 256 entries are for Red/Green
+    // last 256 entries are for Green
+    Uint16 palette[2*256];
 
-	Uint16             palette[256];
-};
+    Uint8* buffer;
+
+    // these two fields MUST be in this order
+    Uint8* texturemem;
+    size_t texturemem_size;
+
+    int    width;
+    int    height;
+    int    pitch;
+} WiiVideo;
 
 void WII_InitVideoSystem();
-void WII_VideoStart();
-void WII_VideoStop();
 void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
 
 #endif /* _SDL_wiivideo_h */
-- 
2.30.2


From 0df626afc1af7a8ba028f06d759de9f0ed174deb Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Sun, 14 Jun 2020 14:01:07 +0200
Subject: [PATCH 05/24] Delete unnecessary file

---
 src/file/wii/SDL_wiirwops.c | 157 ------------------------------------
 1 file changed, 157 deletions(-)
 delete mode 100644 src/file/wii/SDL_wiirwops.c

diff --git a/src/file/wii/SDL_wiirwops.c b/src/file/wii/SDL_wiirwops.c
deleted file mode 100644
index 471237bbc..000000000
--- a/src/file/wii/SDL_wiirwops.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
-SDL - Simple DirectMedia Layer
-Copyright (C) 1997-2006 Sam Lantinga
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-Sam Lantinga
-slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* This file provides a general interface for SDL to read and write
-data sources.  It can easily be extended to files, memory, etc.
-*/
-
-#include "SDL_endian.h"
-#include "SDL_rwops.h"
-
-#ifdef __WII__
-
-#include <stdbool.h>
-#include <stdio.h>
-#include <sys/stat.h>
-
-static SDL_bool initialised = SDL_FALSE;
-
-extern bool fatInitDefault(void);
-
-static int SDLCALL wii_seek(SDL_RWops *context, int offset, int whence)
-{
-	int action;
-
-	switch (whence)
-	{
-		case RW_SEEK_CUR:
-			action = SEEK_CUR;
-			break;
-		case RW_SEEK_END:
-			action = SEEK_END;
-			break;
-		case RW_SEEK_SET:
-			action = SEEK_SET;
-			break;
-		default:
-			SDL_Error(SDL_EFSEEK);
-			return(-1);
-	}
-
-	if ( fseek(context->hidden.wii.fp, offset, action) == 0 ) {
-		return ftell(context->hidden.wii.fp);
-	} else {
-		SDL_Error(SDL_EFSEEK);
-		return(-1);
-	}
-}
-
-static int SDLCALL wii_read(SDL_RWops *context, void *ptr, int size, int num)
-{
-	int bytes_read;
-	bytes_read = fread(ptr, size, num, context->hidden.wii.fp);
-	if ( bytes_read == -1) {
-		SDL_Error(SDL_EFREAD);
-		return(-1);
-	}
-	return(bytes_read);
-}
-
-static int SDLCALL wii_write(SDL_RWops *context, const void *ptr, int size, int num)
-{
-	int bytes_written;
-
-	bytes_written = fwrite(ptr, size, num, context->hidden.wii.fp);
-	if ( bytes_written != (size * num) ) {
-		SDL_Error(SDL_EFWRITE);
-		return(-1);
-	}
-	return(num);
-}
-
-static int SDLCALL wii_close(SDL_RWops *context)
-{
-	if ( context )
-	{
-		fclose(context->hidden.wii.fp);
-		SDL_FreeRW(context);
-	}
-	return(0);
-}
-
-SDL_RWops *SDL_RWFromFile(const char *file, const char *mode)
-{
-	int stat_result;
-	struct stat stat_info;
-	FILE* fp;
-
-	if (!file || !*file || !mode || !*mode)
-	{
-		SDL_SetError("SDL_RWFromFile(): No file or no mode specified");
-		return NULL;
-	}
-
-	/* Initialise the SD library */
-	if (!initialised)
-	{
-		fatInitDefault();
-		initialised = SDL_TRUE;
-	}
-
-	/* Opening for reading? */
-	memset(&stat_info, 0, sizeof(stat_info));
-	if (mode[0] == 'r')
-	{
-		/* Find the file */
-		stat_result = stat(file, &stat_info);
-		if (stat_result != 0)
-		{
-			SDL_SetError("Couldn't find %s to get its length", file);
-			return NULL;
-		}
-	}
-
-	/* Open the file */
-	fp = fopen(file, mode);
-	if ( fp == NULL )
-	{
-		SDL_SetError("Couldn't open %s", file);
-		return NULL;
-	}
-	else
-	{
-		SDL_RWops *rwops = SDL_AllocRW();
-		if ( rwops != NULL )
-		{
-			rwops->seek = wii_seek;
-			rwops->read = wii_read;
-			rwops->write = wii_write;
-			rwops->close = wii_close;
-			rwops->hidden.wii.fp = fp;
-			rwops->hidden.wii.size = stat_info.st_size;
-		}
-		return(rwops);
-	}
-}
-
-#endif /* __WII__ */
-- 
2.30.2


From a527e630e9abd89c44add5dd544d2ce68f2cd3df Mon Sep 17 00:00:00 2001
From: Sergio Padrino <sergio.padrino@gmail.com>
Date: Tue, 16 Jun 2020 14:17:34 +0200
Subject: [PATCH 06/24] Use tueidj's aesndlib-based audio driver for Wii

---
 src/audio/wii/SDL_wiiaudio.c | 294 ++++++++++++++++++++---------------
 src/audio/wii/SDL_wiiaudio.h |  27 ++--
 2 files changed, 187 insertions(+), 134 deletions(-)

diff --git a/src/audio/wii/SDL_wiiaudio.c b/src/audio/wii/SDL_wiiaudio.c
index b97cfd11a..6255416f5 100644
--- a/src/audio/wii/SDL_wiiaudio.c
+++ b/src/audio/wii/SDL_wiiaudio.c
@@ -31,207 +31,251 @@
 #include "../SDL_audio_c.h"
 
 // Wii audio internal includes.
-#include <ogcsys.h>
-#include <ogc/audio.h>
-#include <ogc/cache.h>
 #include "SDL_wiiaudio.h"
 
-#define SAMPLES_PER_DMA_BUFFER (512)
+#include <stdio.h>
+
+// for memalign
+#include <malloc.h>
 
 static const char WIIAUD_DRIVER_NAME[] = "wii";
-static Uint32 dma_buffers[2][SAMPLES_PER_DMA_BUFFER*8] __attribute__((aligned(32)));
-static int dma_buffers_size[2] = { SAMPLES_PER_DMA_BUFFER*4, SAMPLES_PER_DMA_BUFFER*4 };
-static Uint8 whichab = 0;
 
-#define AUDIOSTACK 16384*2
-static lwpq_t audioqueue;
-static lwp_t athread = LWP_THREAD_NULL;
-static Uint8 astack[AUDIOSTACK];
-static bool stopaudio = false;
-static int currentfreq;
+#define DMA_BUFFER_SIZE (SAMPLES_PER_DMA_BUFFER*2*sizeof(short))
+
+static lwp_t athread;
+static WiiAudio *current = NULL;
 
 /****************************************************************************
  * Audio Threading
  ***************************************************************************/
 static void *
-AudioThread (void *arg)
+AudioThread (WiiAudio *private)
 {
+	u32 buffer_size;
+	Uint8 whichab = 1;
+
 	while (1)
 	{
-		if(stopaudio)
+		LWP_SuspendThread(athread);
+		if (private->stopaudio)
 			break;
 
-		memset(dma_buffers[whichab], 0, SAMPLES_PER_DMA_BUFFER*4);
+		DCZeroRange(private->dma_buffers[whichab], DMA_BUFFER_SIZE);
+		buffer_size = DMA_BUFFER_SIZE;
 
 		// Is the device ready?
-		if (!current_audio || current_audio->paused)
+		if (current_audio && !current_audio->paused)
 		{
-			DCFlushRange(dma_buffers[whichab], SAMPLES_PER_DMA_BUFFER*4);
-			dma_buffers_size[whichab] = SAMPLES_PER_DMA_BUFFER*4;
+			SDL_LockMutex(current_audio->mixer_lock);
+
+			if (current_audio->convert.needed)
+			{
+				// Get the client to produce audio
+				current_audio->spec.callback(
+						current_audio->spec.userdata,
+						current_audio->convert.buf,
+						current_audio->convert.len);
+
+				// Convert the audio
+				SDL_ConvertAudio(&current_audio->convert);
+
+				// Copy from SDL buffer to DMA buffer
+				memcpy(private->dma_buffers[whichab], current_audio->convert.buf, current_audio->convert.len_cvt);
+				buffer_size = current_audio->convert.len_cvt;
+			} else {
+				current_audio->spec.callback(
+					current_audio->spec.userdata,
+					(Uint8 *)(private->dma_buffers[whichab]),
+					DMA_BUFFER_SIZE);
+				buffer_size = DMA_BUFFER_SIZE;
+			}
+
+			SDL_UnlockMutex(current_audio->mixer_lock);
 		}
-		else if (current_audio->convert.needed) // Is conversion required?
+		else if (current_audio && (current_audio->spec.format&0x8000)==0) // hack
 		{
-			SDL_mutexP(current_audio->mixer_lock);
-			// Get the client to produce audio
-			current_audio->spec.callback(
-				current_audio->spec.userdata,
-				current_audio->convert.buf,
-				current_audio->convert.len);
-			SDL_mutexV(current_audio->mixer_lock);
-
-			// Convert the audio
-			SDL_ConvertAudio(&current_audio->convert);
-
-			// Copy from SDL buffer to DMA buffer
-			memcpy(dma_buffers[whichab], current_audio->convert.buf, current_audio->convert.len_cvt);
-			DCFlushRange(dma_buffers[whichab], current_audio->convert.len_cvt);
-			dma_buffers_size[whichab] = current_audio->convert.len_cvt;
-		}
-		else
-		{
-			SDL_mutexP(current_audio->mixer_lock);
-			current_audio->spec.callback(
-				current_audio->spec.userdata,
-				(Uint8 *)dma_buffers[whichab],
-				SAMPLES_PER_DMA_BUFFER*4);
-			DCFlushRange(dma_buffers[whichab], SAMPLES_PER_DMA_BUFFER*4);
-			dma_buffers_size[whichab] = SAMPLES_PER_DMA_BUFFER*4;
-			SDL_mutexV(current_audio->mixer_lock);
+			int i;
+			// if it's an unsigned format use 0x8000 for silence (16-bit)
+			short fill = 0x8000;
+
+			// 0x80 for 8-bit formats
+			if (current_audio->spec.format&0x08)
+				fill |= 0x80;
+
+			for (i=0; i < SAMPLES_PER_DMA_BUFFER*2; i++)
+				private->dma_buffers[whichab][i] = fill;
 		}
-		LWP_ThreadSleep (audioqueue);
+
+		AESND_SetVoiceBuffer(private->voice, private->dma_buffers[whichab], buffer_size);
+		whichab ^= 1;
 	}
 	return NULL;
 }
 
 /****************************************************************************
  * DMACallback
- * Playback audio and signal audio thread that more samples are required
+ * signal audio thread that more samples are required
  ***************************************************************************/
 static void
-DMACallback()
+DMACallback(AESNDPB *pb, u32 state)
 {
-	whichab ^= 1;
-	AUDIO_InitDMA ((Uint32)dma_buffers[whichab], dma_buffers_size[whichab]);
-	LWP_ThreadSignal (audioqueue);
+	if (state == VOICE_STATE_STREAM)
+		LWP_ResumeThread(athread);
 }
 
-void WII_AudioStop()
+void WII_AudioStop(WiiAudio *private)
 {
-	AUDIO_StopDMA ();
-	AUDIO_RegisterDMACallback(0);
-	stopaudio = true;
-	LWP_ThreadSignal(audioqueue);
-	LWP_JoinThread(athread, NULL);
-	LWP_CloseQueue (audioqueue);
-	athread = LWP_THREAD_NULL;
-}
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
 
-void WII_AudioStart()
-{
-	if (currentfreq == 32000)
-		AUDIO_SetDSPSampleRate(AI_SAMPLERATE_32KHZ);
-	else
-		AUDIO_SetDSPSampleRate(AI_SAMPLERATE_48KHZ);
-
-	// startup conversion thread
-	stopaudio = false;
-	LWP_InitQueue (&audioqueue);
-	LWP_CreateThread (&athread, AudioThread, NULL, astack, AUDIOSTACK, 67);
-
-	// Start the first chunk of audio playing
-	AUDIO_RegisterDMACallback(DMACallback);
-	DMACallback();
-	AUDIO_StartDMA();
+	if (private->voice) {
+		AESND_SetVoiceStop(private->voice, 1);
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+	}
+
+	private->stopaudio = true;
+	if (athread != LWP_THREAD_NULL) {
+		LWP_ResumeThread(athread);
+		LWP_JoinThread(athread, NULL);
+		athread = LWP_THREAD_NULL;
+	}
+
+	AESND_Pause(1);
+	// this function is broken
+	//AESND_Reset();
 }
 
-static int WIIAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+int WII_AudioStart(WiiAudio *private)
 {
-	if (spec->freq != 32000 && spec->freq != 48000)
-		spec->freq = 32000;
+	if (private==NULL) {
+		if (current==NULL)
+			return -1;
+		private = current;
+	}
 
-	// Set up actual spec.
-	spec->format	= AUDIO_S16MSB;
-	spec->channels	= 2;
-	spec->samples	= SAMPLES_PER_DMA_BUFFER;
-	spec->padding	= 0;
-	SDL_CalculateAudioSpec(spec);
+	memset(private->dma_buffers, 0, sizeof(private->dma_buffers));
+	private->stopaudio = false;
+	private->voice = AESND_AllocateVoice(DMACallback);
+	if (private->voice==NULL)
+		return -1;
 
-	memset(dma_buffers[0], 0, sizeof(dma_buffers[0]));
-	memset(dma_buffers[1], 0, sizeof(dma_buffers[0]));
+	if (LWP_CreateThread(&athread, (void*(*)(void*))AudioThread, private, private->astack, AUDIOSTACK, 80) < 0) {
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+		return -1;
+	}
 
-	currentfreq = spec->freq;
-	WII_AudioStart();
+	// start audio
+	// this is retarded. Why isn't there one function to do all this shit?
+	AESND_SetVoiceFormat(private->voice, private->format);
+	AESND_SetVoiceFrequency(private->voice, private->freq);
+	AESND_SetVoiceBuffer(private->voice, private->dma_buffers[0], DMA_BUFFER_SIZE);
+	AESND_SetVoiceStream(private->voice, true);
+	AESND_SetVoiceStop(private->voice, 0);
+	AESND_Pause(0);
 
+	current = private;
 	return 1;
 }
 
-void static WIIAUD_WaitAudio(_THIS)
+static int WIIAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
 {
+	u32 format;
+	WiiAudio *private = (WiiAudio*)(this->hidden);
 
-}
+	if (spec->freq <= 0 || spec->freq > 144000)
+		spec->freq = DSP_DEFAULT_FREQ;
 
-static void WIIAUD_PlayAudio(_THIS)
-{
+	// default sample size = 1 byte (1 channel @ 8 bits)
+	spec->samples = DMA_BUFFER_SIZE;
 
-}
+	// no support for little endian or 16 bit unsigned
+	switch (spec->format) {
+		case AUDIO_U8:
+			format = VOICE_MONO8_UNSIGNED;
+			break;
+		case AUDIO_S8:
+			format = VOICE_MONO8;
+			break;
+		// anything else needs conversion to signed 16 big-endian
+		default:
+		case AUDIO_U16LSB:
+		case AUDIO_U16MSB:
+		case AUDIO_S16LSB:
+			spec->format = AUDIO_S16MSB;
+			// fallthrough
+		case AUDIO_S16MSB:
+			format = VOICE_MONO16;
+			// samples are 16 bits
+			spec->samples >>= 1;
+	}
 
-static Uint8 *WIIAUD_GetAudioBuf(_THIS)
-{
-	return NULL;
+	// support 2 channels max
+	if (spec->channels > 2)
+		spec->channels = 2;
+
+	if (spec->channels == 2) {
+		++format;
+		// 2 values for each sample
+		spec->samples >>= 1;
+	}
+
+	spec->padding	= 0;
+	SDL_CalculateAudioSpec(spec);
+
+	private->format = format;
+	// AESND will convert frequency as required
+	private->freq = spec->freq;
+
+	return WII_AudioStart(private);
 }
 
 static void WIIAUD_CloseAudio(_THIS)
 {
-	// Stop any DMA going on
-	AUDIO_StopDMA();
-
-	// terminate conversion thread
-	LWP_ThreadSignal(audioqueue);
+	WII_AudioStop((WiiAudio*)(this->hidden));
+	current = NULL;
 }
 
-static void WIIAUD_DeleteDevice(SDL_AudioDevice *device)
+static void WIIAUD_DeleteDevice(_THIS)
 {
-	// Forget the DMA callback
-	AUDIO_RegisterDMACallback(0);
+	WII_AudioStop((WiiAudio*)(this->hidden));
 
-	// Stop any DMA going on
-	AUDIO_StopDMA();
-
-	// terminate conversion thread
-	LWP_ThreadSignal(audioqueue);
-
-	SDL_free(device->hidden);
-	SDL_free(device);
+	free(this->hidden);
+	SDL_free(this);
 }
 
 static SDL_AudioDevice *WIIAUD_CreateDevice(int devindex)
 {
 	SDL_AudioDevice *this;
 
+	athread = LWP_THREAD_NULL;
+
 	/* Initialize all variables that we clean on shutdown */
 	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
 	if ( this ) {
 		SDL_memset(this, 0, (sizeof *this));
-		this->hidden = (struct SDL_PrivateAudioData *)
-				SDL_malloc((sizeof *this->hidden));
+		this->hidden = (WiiAudio*)memalign(32, sizeof(WiiAudio));
 	}
 	if ( (this == NULL) || (this->hidden == NULL) ) {
 		SDL_OutOfMemory();
-		if ( this ) {
-			SDL_free(this);
-		}
-		return(0);
+		SDL_free(this);
+		return NULL;
 	}
-	SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+	SDL_memset(this->hidden, 0, sizeof(WiiAudio));
 
 	// Initialise the Wii side of the audio system
-	AUDIO_Init(0);
+	AESND_Init();
+	AESND_Pause(1);
 
 	/* Set the function pointers */
 	this->OpenAudio = WIIAUD_OpenAudio;
-	this->WaitAudio = WIIAUD_WaitAudio;
-	this->PlayAudio = WIIAUD_PlayAudio;
-	this->GetAudioBuf = WIIAUD_GetAudioBuf;
+	//this->WaitAudio = WIIAUD_WaitAudio;
+	//this->PlayAudio = WIIAUD_PlayAudio;
+	//this->GetAudioBuf = WIIAUD_GetAudioBuf;
 	this->CloseAudio = WIIAUD_CloseAudio;
 	this->free = WIIAUD_DeleteDevice;
 
diff --git a/src/audio/wii/SDL_wiiaudio.h b/src/audio/wii/SDL_wiiaudio.h
index ef759be0d..6d3c74556 100644
--- a/src/audio/wii/SDL_wiiaudio.h
+++ b/src/audio/wii/SDL_wiiaudio.h
@@ -24,17 +24,26 @@
 #ifndef _SDL_wiiaudio_h
 #define _SDL_wiiaudio_h
 
+#include <ogcsys.h>
+#include <aesndlib.h>
+
 #include "../SDL_sysaudio.h"
 
 /* Hidden "this" pointer for the video functions */
-#define _THIS	SDL_AudioDevice *this
-
-struct SDL_PrivateAudioData {
-	/* The file descriptor for the audio device */
-	Uint8 *mixbuf;
-	Uint32 mixlen;
-	Uint32 write_delay;
-	Uint32 initial_calls;
-};
+#define _THIS   SDL_AudioDevice *this
+
+#define AUDIOSTACK 8192
+#define SAMPLES_PER_DMA_BUFFER (DSP_STREAMBUFFER_SIZE)
+
+typedef struct SDL_PrivateAudioData {
+    // these go first so they will be aligned
+    Uint8 astack[AUDIOSTACK];
+    short dma_buffers[2][SAMPLES_PER_DMA_BUFFER*2];
+
+    AESNDPB* voice;
+    u32 format;
+    u32 freq;
+    volatile bool stopaudio;
+} WiiAudio;
 
 #endif /* _SDL_dummyaudio_h */
-- 
2.30.2


From 3d4f7452cacd3f8723262ce0234a41c92d537821 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 14:49:47 +0100
Subject: [PATCH 07/24] redefine main for wii

---
 include/SDL_main.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/SDL_main.h b/include/SDL_main.h
index ab50ef1e2..fc82b7a43 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -32,7 +32,7 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS)
+    defined(__SYMBIAN32__) || defined(QWS) || defined(__WII__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
-- 
2.30.2


From 1feb0fac749eb8a5493611406c9ae254828061e3 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 14:53:03 +0100
Subject: [PATCH 08/24] prevent buffer overflow

---
 src/joystick/wii/SDL_sysjoystick.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/src/joystick/wii/SDL_sysjoystick.c b/src/joystick/wii/SDL_sysjoystick.c
index 1b9ce8f5d..8be904496 100644
--- a/src/joystick/wii/SDL_sysjoystick.c
+++ b/src/joystick/wii/SDL_sysjoystick.c
@@ -130,10 +130,10 @@ static const u16 sdl_buttons_gc[] =
 	PAD_TRIGGER_R
 };
 
-static int __jswpad_enabled = 1;
-static int __jspad_enabled = 1;
-static int __numwiijoysticks = 4;
-static int __numgcjoysticks = 4;
+static const int __jswpad_enabled = 1;
+static const int __jspad_enabled = 1;
+static const int __numwiijoysticks = 4;
+static const int __numgcjoysticks = 4;
 
 /* Helpers to separate nunchuk vs classic buttons which share the
  * same scan codes. In particular, up on the classic controller is
@@ -164,10 +164,13 @@ static char joy_name[] = "Gamecube 0";
 /* Function to get the device-dependent name of a joystick */
 const char *SDL_SYS_JoystickName(int index)
 {
-	if((index < 4) && (__jswpad_enabled) && (index < __numwiijoysticks))
-	sprintf(joy_name, "Wiimote %d", index);
-	else if((index < 8) && (__jspad_enabled) && (index < (__numgcjoysticks + 4)) && (index> 3))
-	sprintf(joy_name, "Gamecube %d", index);
+	if(index>=0) {
+
+		if((index < 4) && (__jswpad_enabled) && (index < __numwiijoysticks))
+			sprintf(joy_name, "Wiimote %d", index);
+		else if((index < 8) && (__jspad_enabled) && (index < (__numgcjoysticks + 4)) && (index> 3))
+			sprintf(joy_name, "Gamecube %d", index);
+	}
 	return (const char *)joy_name;
 }
 
-- 
2.30.2


From db5bf7d7fec1c9ab56250a6b4ebaf54dd493d575 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 20:41:11 +0100
Subject: [PATCH 09/24] move threads to common implementation

---
 configure.in                              | 4 ++--
 include/SDL_config.h.in                   | 2 +-
 src/thread/SDL_thread_c.h                 | 4 ++--
 src/thread/{wii => ogc}/SDL_syscond.c     | 0
 src/thread/{wii => ogc}/SDL_sysmutex.c    | 0
 src/thread/{wii => ogc}/SDL_sysmutex_c.h  | 0
 src/thread/{wii => ogc}/SDL_syssem.c      | 0
 src/thread/{wii => ogc}/SDL_systhread.c   | 0
 src/thread/{wii => ogc}/SDL_systhread_c.h | 0
 9 files changed, 5 insertions(+), 5 deletions(-)
 rename src/thread/{wii => ogc}/SDL_syscond.c (100%)
 rename src/thread/{wii => ogc}/SDL_sysmutex.c (100%)
 rename src/thread/{wii => ogc}/SDL_sysmutex_c.h (100%)
 rename src/thread/{wii => ogc}/SDL_syssem.c (100%)
 rename src/thread/{wii => ogc}/SDL_systhread.c (100%)
 rename src/thread/{wii => ogc}/SDL_systhread_c.h (100%)

diff --git a/configure.in b/configure.in
index 7e913a109..324a5a5f0 100644
--- a/configure.in
+++ b/configure.in
@@ -950,8 +950,8 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
         AC_DEFINE(SDL_JOYSTICK_WII)
         SOURCES="$SOURCES $srcdir/src/joystick/wii/*.c"
         have_joystick=yes
-        AC_DEFINE(SDL_THREAD_WII)
-        SOURCES="$SOURCES $srcdir/src/thread/wii/*.c"
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
         have_threads=yes
         AC_DEFINE(SDL_VIDEO_DRIVER_WII)
         SOURCES="$SOURCES $srcdir/src/video/wii/*.c"
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 6db1d6b26..fbebfcb97 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -240,7 +240,7 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_SPROC
-#undef SDL_THREAD_WII
+#undef SDL_THREAD_OGC
 #undef SDL_THREAD_WIN32
 
 /* Enable various timer systems */
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 911756747..e2c21bd6f 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -43,8 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
-#elif SDL_THREAD_WII
-#include "wii/SDL_systhread_c.h"
+#elif SDL_THREAD_OGC
+#include "ogc/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/wii/SDL_syscond.c b/src/thread/ogc/SDL_syscond.c
similarity index 100%
rename from src/thread/wii/SDL_syscond.c
rename to src/thread/ogc/SDL_syscond.c
diff --git a/src/thread/wii/SDL_sysmutex.c b/src/thread/ogc/SDL_sysmutex.c
similarity index 100%
rename from src/thread/wii/SDL_sysmutex.c
rename to src/thread/ogc/SDL_sysmutex.c
diff --git a/src/thread/wii/SDL_sysmutex_c.h b/src/thread/ogc/SDL_sysmutex_c.h
similarity index 100%
rename from src/thread/wii/SDL_sysmutex_c.h
rename to src/thread/ogc/SDL_sysmutex_c.h
diff --git a/src/thread/wii/SDL_syssem.c b/src/thread/ogc/SDL_syssem.c
similarity index 100%
rename from src/thread/wii/SDL_syssem.c
rename to src/thread/ogc/SDL_syssem.c
diff --git a/src/thread/wii/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
similarity index 100%
rename from src/thread/wii/SDL_systhread.c
rename to src/thread/ogc/SDL_systhread.c
diff --git a/src/thread/wii/SDL_systhread_c.h b/src/thread/ogc/SDL_systhread_c.h
similarity index 100%
rename from src/thread/wii/SDL_systhread_c.h
rename to src/thread/ogc/SDL_systhread_c.h
-- 
2.30.2


From 3f814ef063ac849d87b8cd12cc7ed37252766225 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 20:46:20 +0100
Subject: [PATCH 10/24] use portlibs includes & libs

---
 configure.in | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/configure.in b/configure.in
index 324a5a5f0..2dd0b67e7 100644
--- a/configure.in
+++ b/configure.in
@@ -934,13 +934,16 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
         ARCH=nintendo-wii
         WII_CFLAGS="-mrvl -mcpu=750 -meabi -mhard-float \
                      -Wall -O2 \
-                     -I${DEVKITPRO}/libogc/include -DGEKKO"
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/wii/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
         EXTRA_CFLAGS="$EXTRA_CFLAGS $WII_CFLAGS"
         CFLAGS="$CFLAGS $WII_CFLAGS"
         SDL_CFLAGS="$SDL_CFLAGS $WII_CFLAGS"
         SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
-                  -L${DEVKITPRO}/portlibs/wii/lib $SDL_LIBS \
-                  -L${DEVKITPRO}/libogc/lib -logc"
+                  -L${DEVKITPRO}/portlibs/wii/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/wii -logc"
         AC_DEFINE(SDL_TIMER_WII)
         SOURCES="$SOURCES $srcdir/src/timer/wii/*.c"
         have_timers=yes
-- 
2.30.2


From b171a8e635883c54ba79e29d574d34acee7366c1 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 20:51:31 +0100
Subject: [PATCH 11/24] move audio to common implementation

---
 configure.in                                  |  4 +-
 include/SDL_config.h.in                       |  2 +-
 src/audio/SDL_audio.c                         |  4 +-
 src/audio/SDL_sysaudio.h                      |  4 +-
 .../SDL_wiiaudio.c => ogc/SDL_ogcAudio.c}     | 48 +++++++++----------
 .../SDL_wiiaudio.h => ogc/SDL_ogcAudio.h}     |  6 +--
 6 files changed, 34 insertions(+), 34 deletions(-)
 rename src/audio/{wii/SDL_wiiaudio.c => ogc/SDL_ogcAudio.c} (83%)
 rename src/audio/{wii/SDL_wiiaudio.h => ogc/SDL_ogcAudio.h} (92%)

diff --git a/configure.in b/configure.in
index 2dd0b67e7..a56e37554 100644
--- a/configure.in
+++ b/configure.in
@@ -947,8 +947,8 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
         AC_DEFINE(SDL_TIMER_WII)
         SOURCES="$SOURCES $srcdir/src/timer/wii/*.c"
         have_timers=yes
-        AC_DEFINE(SDL_AUDIO_DRIVER_WII)
-        SOURCES="$SOURCES $srcdir/src/audio/wii/*.c"
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
         have_audio=yes
         AC_DEFINE(SDL_JOYSTICK_WII)
         SOURCES="$SOURCES $srcdir/src/joystick/wii/*.c"
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index fbebfcb97..29a6f3dc4 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -185,7 +185,7 @@
 #undef SDL_AUDIO_DRIVER_SNDMGR
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WAVEOUT
-#undef SDL_AUDIO_DRIVER_WII
+#undef SDL_AUDIO_DRIVER_OGC
 
 /* Enable various cdrom drivers */
 #undef SDL_CDROM_AIX
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index 4e8d3d542..fbbeb459f 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -113,8 +113,8 @@ static AudioBootStrap *bootstrap[] = {
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 	&EPOCAudio_bootstrap,
 #endif
-#if SDL_AUDIO_DRIVER_WII
-	&WIIAUD_bootstrap,
+#if SDL_AUDIO_DRIVER_OGC
+	&OGCAUD_bootstrap,
 #endif
 	NULL
 };
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 5ee8e6b2f..e701a570a 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -179,8 +179,8 @@ extern AudioBootStrap DART_bootstrap;
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 extern AudioBootStrap EPOCAudio_bootstrap; 
 #endif
-#if SDL_AUDIO_DRIVER_WII
-extern AudioBootStrap WIIAUD_bootstrap;
+#if SDL_AUDIO_DRIVER_OGC
+extern AudioBootStrap OGCAUD_bootstrap;
 #endif
 
 /* This is the current audio device */
diff --git a/src/audio/wii/SDL_wiiaudio.c b/src/audio/ogc/SDL_ogcAudio.c
similarity index 83%
rename from src/audio/wii/SDL_wiiaudio.c
rename to src/audio/ogc/SDL_ogcAudio.c
index 6255416f5..70b7f9b6d 100644
--- a/src/audio/wii/SDL_wiiaudio.c
+++ b/src/audio/ogc/SDL_ogcAudio.c
@@ -31,25 +31,25 @@
 #include "../SDL_audio_c.h"
 
 // Wii audio internal includes.
-#include "SDL_wiiaudio.h"
+#include "SDL_ogcAudio.h"
 
 #include <stdio.h>
 
 // for memalign
 #include <malloc.h>
 
-static const char WIIAUD_DRIVER_NAME[] = "wii";
+static const char OGCAUD_DRIVER_NAME[] = "ogc";
 
 #define DMA_BUFFER_SIZE (SAMPLES_PER_DMA_BUFFER*2*sizeof(short))
 
 static lwp_t athread;
-static WiiAudio *current = NULL;
+static ogcAudio *current = NULL;
 
 /****************************************************************************
  * Audio Threading
  ***************************************************************************/
 static void *
-AudioThread (WiiAudio *private)
+AudioThread (ogcAudio *private)
 {
 	u32 buffer_size;
 	Uint8 whichab = 1;
@@ -123,7 +123,7 @@ DMACallback(AESNDPB *pb, u32 state)
 		LWP_ResumeThread(athread);
 }
 
-void WII_AudioStop(WiiAudio *private)
+void OGC_AudioStop(ogcAudio *private)
 {
 	if (private==NULL) {
 		if (current==NULL)
@@ -149,7 +149,7 @@ void WII_AudioStop(WiiAudio *private)
 	//AESND_Reset();
 }
 
-int WII_AudioStart(WiiAudio *private)
+int OGC_AudioStart(ogcAudio *private)
 {
 	if (private==NULL) {
 		if (current==NULL)
@@ -182,10 +182,10 @@ int WII_AudioStart(WiiAudio *private)
 	return 1;
 }
 
-static int WIIAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+static int OGCAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
 {
 	u32 format;
-	WiiAudio *private = (WiiAudio*)(this->hidden);
+	ogcAudio *private = (ogcAudio*)(this->hidden);
 
 	if (spec->freq <= 0 || spec->freq > 144000)
 		spec->freq = DSP_DEFAULT_FREQ;
@@ -231,24 +231,24 @@ static int WIIAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
 	// AESND will convert frequency as required
 	private->freq = spec->freq;
 
-	return WII_AudioStart(private);
+	return OGC_AudioStart(private);
 }
 
-static void WIIAUD_CloseAudio(_THIS)
+static void OGCAUD_CloseAudio(_THIS)
 {
-	WII_AudioStop((WiiAudio*)(this->hidden));
+	OGC_AudioStop((ogcAudio*)(this->hidden));
 	current = NULL;
 }
 
-static void WIIAUD_DeleteDevice(_THIS)
+static void OGCAUD_DeleteDevice(_THIS)
 {
-	WII_AudioStop((WiiAudio*)(this->hidden));
+	OGC_AudioStop((ogcAudio*)(this->hidden));
 
 	free(this->hidden);
 	SDL_free(this);
 }
 
-static SDL_AudioDevice *WIIAUD_CreateDevice(int devindex)
+static SDL_AudioDevice *OGCAUD_CreateDevice(int devindex)
 {
 	SDL_AudioDevice *this;
 
@@ -258,36 +258,36 @@ static SDL_AudioDevice *WIIAUD_CreateDevice(int devindex)
 	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
 	if ( this ) {
 		SDL_memset(this, 0, (sizeof *this));
-		this->hidden = (WiiAudio*)memalign(32, sizeof(WiiAudio));
+		this->hidden = (ogcAudio*)memalign(32, sizeof(ogcAudio));
 	}
 	if ( (this == NULL) || (this->hidden == NULL) ) {
 		SDL_OutOfMemory();
 		SDL_free(this);
 		return NULL;
 	}
-	SDL_memset(this->hidden, 0, sizeof(WiiAudio));
+	SDL_memset(this->hidden, 0, sizeof(ogcAudio));
 
-	// Initialise the Wii side of the audio system
+	// Initialise the ogc side of the audio system
 	AESND_Init();
 	AESND_Pause(1);
 
 	/* Set the function pointers */
-	this->OpenAudio = WIIAUD_OpenAudio;
+	this->OpenAudio = OGCAUD_OpenAudio;
 	//this->WaitAudio = WIIAUD_WaitAudio;
 	//this->PlayAudio = WIIAUD_PlayAudio;
 	//this->GetAudioBuf = WIIAUD_GetAudioBuf;
-	this->CloseAudio = WIIAUD_CloseAudio;
-	this->free = WIIAUD_DeleteDevice;
+	this->CloseAudio = OGCAUD_CloseAudio;
+	this->free = OGCAUD_DeleteDevice;
 
 	return this;
 }
 
-static int WIIAUD_Available(void)
+static int OGCAUD_Available(void)
 {
 	return 1;
 }
 
-AudioBootStrap WIIAUD_bootstrap = {
-	WIIAUD_DRIVER_NAME, "SDL Wii audio driver",
-	WIIAUD_Available, WIIAUD_CreateDevice
+AudioBootStrap OGCAUD_bootstrap = {
+	OGCAUD_DRIVER_NAME, "SDL ogc audio driver",
+	OGCAUD_Available, OGCAUD_CreateDevice
 };
diff --git a/src/audio/wii/SDL_wiiaudio.h b/src/audio/ogc/SDL_ogcAudio.h
similarity index 92%
rename from src/audio/wii/SDL_wiiaudio.h
rename to src/audio/ogc/SDL_ogcAudio.h
index 6d3c74556..57a44f34b 100644
--- a/src/audio/wii/SDL_wiiaudio.h
+++ b/src/audio/ogc/SDL_ogcAudio.h
@@ -21,8 +21,8 @@
 */
 #include "SDL_config.h"
 
-#ifndef _SDL_wiiaudio_h
-#define _SDL_wiiaudio_h
+#ifndef _SDL_ogcAudio_h
+#define _SDL_ogcAudio_h
 
 #include <ogcsys.h>
 #include <aesndlib.h>
@@ -44,6 +44,6 @@ typedef struct SDL_PrivateAudioData {
     u32 format;
     u32 freq;
     volatile bool stopaudio;
-} WiiAudio;
+} ogcAudio;
 
 #endif /* _SDL_dummyaudio_h */
-- 
2.30.2


From 508ea2710df8f7c2af8d7e681cf6d931813c92ee Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Tue, 16 Jun 2020 20:58:02 +0100
Subject: [PATCH 12/24] move timers to common implementation

---
 configure.in                          | 4 ++--
 include/SDL_config.h.in               | 2 +-
 src/timer/{wii => ogc}/SDL_systimer.c | 2 +-
 3 files changed, 4 insertions(+), 4 deletions(-)
 rename src/timer/{wii => ogc}/SDL_systimer.c (94%)

diff --git a/configure.in b/configure.in
index a56e37554..c7cf0954c 100644
--- a/configure.in
+++ b/configure.in
@@ -944,8 +944,8 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
                   -L${DEVKITPRO}/portlibs/wii/lib \
                   -L${DEVKITPRO}/portlibs/ppc/lib $SDL_LIBS \
                   -L${DEVKITPRO}/libogc/lib/wii -logc"
-        AC_DEFINE(SDL_TIMER_WII)
-        SOURCES="$SOURCES $srcdir/src/timer/wii/*.c"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
         have_timers=yes
         AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
         SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 29a6f3dc4..cb41a07e2 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -252,7 +252,7 @@
 #undef SDL_TIMER_OS2
 #undef SDL_TIMER_RISCOS
 #undef SDL_TIMER_UNIX
-#undef SDL_TIMER_WII
+#undef SDL_TIMER_OGC
 #undef SDL_TIMER_WIN32
 #undef SDL_TIMER_WINCE
 
diff --git a/src/timer/wii/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
similarity index 94%
rename from src/timer/wii/SDL_systimer.c
rename to src/timer/ogc/SDL_systimer.c
index 164178413..03fa76445 100644
--- a/src/timer/wii/SDL_systimer.c
+++ b/src/timer/ogc/SDL_systimer.c
@@ -21,7 +21,7 @@
 */
 #include "SDL_config.h"
 
-#ifdef SDL_TIMER_WII
+#ifdef SDL_TIMER_OGC
 
 #include <ogc/lwp_watchdog.h>
 #include <ogc/video.h>
-- 
2.30.2


From eb201144bd759581ffc8ed345874da0cc157a129 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Wed, 17 Jun 2020 01:05:25 +0100
Subject: [PATCH 13/24] add gamecube sdl main

---
 include/SDL_main.h                    |  3 ++-
 src/main/gamecube/SDL_gamecube_main.c | 26 ++++++++++++++++++++++++++
 2 files changed, 28 insertions(+), 1 deletion(-)
 create mode 100644 src/main/gamecube/SDL_gamecube_main.c

diff --git a/include/SDL_main.h b/include/SDL_main.h
index fc82b7a43..bc5142773 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -32,7 +32,8 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS) || defined(__WII__)
+    defined(__SYMBIAN32__) || defined(QWS) || \
+    defined(__WII__) || defined(__GAMECUBE__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
new file mode 100644
index 000000000..51b5fd3d2
--- /dev/null
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -0,0 +1,26 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/gamecube/SDL_gamecube_video.h"
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+//	SYS_SetPowerCallback(ShutdownCB);
+//	SYS_SetResetCallback(ResetCB);
+	PAD_Init();
+	GAMECUBE_InitVideoSystem();
+	fatInitDefault();
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
-- 
2.30.2


From 0b6f620cae7b21dd3d5ed40da6b16c2b938150fc Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Wed, 17 Jun 2020 01:21:35 +0100
Subject: [PATCH 14/24] add gamecube video

---
 include/SDL_config.h.in                 |   1 +
 src/video/gamecube/SDL_gamecube_video.c | 818 ++++++++++++++++++++++++
 src/video/gamecube/SDL_gamecube_video.h |  57 ++
 3 files changed, 876 insertions(+)
 create mode 100644 src/video/gamecube/SDL_gamecube_video.c
 create mode 100644 src/video/gamecube/SDL_gamecube_video.h

diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index cb41a07e2..3a33531f7 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -284,6 +284,7 @@
 #undef SDL_VIDEO_DRIVER_TOOLBOX
 #undef SDL_VIDEO_DRIVER_VGL
 #undef SDL_VIDEO_DRIVER_WII
+#undef SDL_VIDEO_DRIVER_GAMECUBE
 #undef SDL_VIDEO_DRIVER_WINDIB
 #undef SDL_VIDEO_DRIVER_WSCONS
 #undef SDL_VIDEO_DRIVER_X11
diff --git a/src/video/gamecube/SDL_gamecube_video.c b/src/video/gamecube/SDL_gamecube_video.c
new file mode 100644
index 000000000..a3a939d98
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_video.c
@@ -0,0 +1,818 @@
+/*
+	SDL - Simple DirectMedia Layer
+	Copyright (C) 1997-2006 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Lesser General Public
+	License as published by the Free Software Foundation; either
+	version 2.1 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+	Tantric, 2009
+*/
+#include "SDL_config.h"
+
+// Standard includes.
+#include <math.h>
+
+// SDL internal includes.
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+
+// SDL Gamecube specifics.
+#include <gccore.h>
+#include <ogcsys.h>
+#include <malloc.h>
+#include "SDL_gamecube_video.h"
+#include <ogc/machine/processor.h>
+
+static const char	GAMECUBEVID_DRIVER_NAME[] = "gamecube";
+static lwp_t videothread = LWP_THREAD_NULL;
+static SDL_mutex *videomutex = NULL;
+static SDL_cond *videocond = NULL;
+static GamecubeVideo *current = NULL;
+
+int vresx=0, vresy=0;
+
+/*** SDL ***/
+static SDL_Rect mode_320, mode_640;
+
+static SDL_Rect* modes_descending[] =
+{
+	&mode_640,
+	&mode_320,
+	NULL
+};
+
+/*** 2D Video ***/
+#define HASPECT 			320
+#define VASPECT 			240
+
+unsigned char *xfb = NULL;
+GXRModeObj* vmode = 0;
+static int quit_flip_thread = 0;
+static GXTexObj texobj_a, texobj_b;
+static GXTlutObj texpalette_a, texpalette_b;
+
+/*** GX ***/
+#define DEFAULT_FIFO_SIZE 256 * 1024
+static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
+
+/* New texture based scaler */
+typedef struct tagcamera
+{
+	guVector pos;
+	guVector up;
+	guVector view;
+}
+camera;
+
+/*** Square Matrix
+     This structure controls the size of the image on the screen.
+	 Think of the output as a -80 x 80 by -60 x 60 graph.
+***/
+static s16 square[] ATTRIBUTE_ALIGN (32) =
+{
+  /*
+   * X,   Y,  Z
+   * Values set are for roughly 4:3 aspect
+   */
+	-HASPECT,  VASPECT, 0,	// 0
+	 HASPECT,  VASPECT, 0,	// 1
+	 HASPECT, -VASPECT, 0,	// 2
+	-HASPECT, -VASPECT, 0	// 3
+};
+
+static const f32 tex_pos[] ATTRIBUTE_ALIGN(32) = {
+	0.0, 0.0,
+	1.0, 0.0,
+	1.0, 1.0,
+	0.0, 1.0,
+};
+
+static camera cam = {
+	{0.0F, 0.0F, 0.0F},
+	{0.0F, 0.5F, 0.0F},
+	{0.0F, 0.0F, -0.5F}
+};
+
+/****************************************************************************
+ * Scaler Support Functions
+ ***************************************************************************/
+static int currentwidth;
+static int currentheight;
+static int currentbpp;
+
+static void
+draw_init(void *palette, void *tex)
+{
+	Mtx m, mv, view;
+
+	GX_ClearVtxDesc ();
+	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
+	GX_SetVtxDesc (GX_VA_TEX0, GX_INDEX8);
+
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
+	GX_SetArray (GX_VA_TEX0, (void*)tex_pos, 2 * sizeof (f32));
+	GX_SetNumTexGens (1);
+	GX_SetNumChans (0);
+
+	GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
+	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
+
+	memset(&view, 0, sizeof (Mtx));
+	guLookAt(view, &cam.pos, &cam.up, &cam.view);
+	guMtxIdentity(m);
+	guMtxTransApply(m, m, 0, 0, -100);
+	guMtxConcat(view, m, mv);
+	GX_LoadPosMtxImm(mv, GX_PNMTX0);
+
+	GX_InvVtxCache ();	// update vertex cache
+
+	if (currentbpp == 8) {
+		GX_InitTlutObj(&texpalette_a, palette, GX_TL_IA8, 256);
+		GX_InitTlutObj(&texpalette_b, (Uint16*)palette+256, GX_TL_IA8, 256);
+		DCStoreRange(palette, sizeof(512*sizeof(Uint16)));
+		GX_LoadTlut(&texpalette_a, GX_TLUT0);
+		GX_LoadTlut(&texpalette_b, GX_TLUT1);
+
+		GX_InitTexObjCI(&texobj_a, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+		GX_InitTexObjCI(&texobj_b, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+		GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+		// Setup TEV to combine Red+Green and Blue paletted images
+		GX_SetTevColor(GX_TEVREG0, (GXColor){255, 255, 0, 0});
+		GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		// first stage = red and green
+		GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+		GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+		// second stage = add blue (and opaque alpha)
+		GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+		GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+		GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+		GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+		GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+		GX_SetNumTevStages(2);
+	}
+	else if (currentbpp == 16)
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
+	else
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);	// load texture object so its ready to use
+}
+
+static inline void
+draw_vert (u8 index)
+{
+	GX_Position1x8 (index);
+	GX_TexCoord1x8 (index);
+}
+
+static inline void
+draw_square ()
+{
+	GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+	draw_vert(0);
+	draw_vert(1);
+	draw_vert(2);
+	draw_vert(3);
+	GX_End();
+}
+
+static void * flip_thread (void *arg)
+{
+	u32 *tex = (u32*)arg;
+
+	GX_SetCurrentGXThread();
+
+	// clear EFB
+	GX_CopyDisp(xfb, GX_TRUE);
+
+	SDL_mutexP(videomutex);
+
+	while(!quit_flip_thread)
+	{
+		// update texture
+		DCStoreRange((void*)tex[0], tex[1]);
+		// clear texture objects
+		GX_InvalidateTexAll();
+		draw_square(); // render textured quad
+
+		VIDEO_WaitVSync();
+		GX_CopyDisp(xfb, GX_FALSE);
+
+		GX_DrawDone();
+
+		SDL_CondWait(videocond, videomutex);
+	}
+	SDL_mutexV(videomutex);
+
+	return NULL;
+}
+
+static void
+SetupGX()
+{
+	Mtx44 p;
+	int df = 1; // deflicker on/off
+
+	GX_SetCurrentGXThread();
+	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
+	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
+	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
+
+	GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
+	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
+
+	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+	GX_SetDispCopyGamma (GX_GM_1_0);
+	GX_SetCullMode (GX_CULL_NONE);
+	GX_SetBlendMode(GX_BM_NONE,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
+
+	GX_SetZMode (GX_FALSE, GX_LEQUAL, GX_TRUE);
+	GX_SetColorUpdate (GX_TRUE);
+	GX_SetAlphaUpdate(GX_FALSE);
+
+	guOrtho(p, VASPECT, -VASPECT, -HASPECT, HASPECT, 100, 1000); // matrix, t, b, l, r, n, f
+	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
+	GX_Flush();
+}
+
+static void
+StartVideoThread(void *args)
+{
+	if(videothread == LWP_THREAD_NULL)
+	{
+		quit_flip_thread = 0;
+		LWP_CreateThread(&videothread, flip_thread, args, NULL, 0, 68);
+	}
+}
+
+void GAMECUBE_VideoStart(GamecubeVideo *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
+
+	SetupGX();
+	draw_init(private->palette, private->texturemem);
+	StartVideoThread(&private->texturemem);
+	current = private;
+}
+
+void WII_VideoStop()
+{
+	if(videothread == LWP_THREAD_NULL)
+		return;
+
+	SDL_LockMutex(videomutex);
+	quit_flip_thread = 1;
+	SDL_CondSignal(videocond);
+	SDL_UnlockMutex(videomutex);
+
+	LWP_JoinThread(videothread, NULL);
+	videothread = LWP_THREAD_NULL;
+}
+
+static int GAMECUBE_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	// Set up the modes.
+	mode_640.w = 640;
+	mode_640.h = 480;
+	mode_320.w = 320;
+	mode_320.h = 240;
+
+	// Set the current format.
+	vformat->BitsPerPixel	= 16;
+	vformat->BytesPerPixel	= 2;
+
+	this->hidden->buffer = NULL;
+	this->hidden->texturemem = NULL;
+	this->hidden->width = 0;
+	this->hidden->height = 0;
+	this->hidden->pitch = 0;
+
+	/* We're done! */
+	return 0;
+}
+
+static SDL_Rect **GAMECUBE_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	return modes_descending;
+}
+
+static SDL_Surface *GAMECUBE_SetVideoMode(_THIS, SDL_Surface *current,
+								   int width, int height, int bpp, Uint32 flags)
+{
+	SDL_Rect* 		mode;
+	size_t			bytes_per_pixel;
+	Uint32			r_mask = 0;
+	Uint32			b_mask = 0;
+	Uint32			g_mask = 0;
+
+	// Find a mode big enough to store the requested resolution
+	mode = modes_descending[0];
+	while (mode)
+	{
+		if (mode->w == width && mode->h == height)
+			break;
+		else
+			++mode;
+	}
+
+	// Didn't find a mode?
+	if (!mode)
+	{
+		SDL_SetError("Display mode (%dx%d) is unsupported.",
+			width, height);
+		return NULL;
+	}
+
+	if(bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
+	{
+		SDL_SetError("Resolution (%d bpp) is unsupported (8/16/24/32 bpp only).",
+			bpp);
+		return NULL;
+	}
+
+	bytes_per_pixel = bpp / 8;
+
+	WII_VideoStop();
+
+	free(this->hidden->buffer);
+	free(this->hidden->texturemem);
+
+	// Allocate the new buffer.
+	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
+	if (!this->hidden->buffer )
+	{
+		this->hidden->texturemem = NULL;
+		SDL_SetError("Couldn't allocate buffer for requested mode");
+		return(NULL);
+	}
+
+	// Allocate texture memory
+	if (bytes_per_pixel > 2)
+		this->hidden->texturemem_size = width * height * 4;
+	else
+		this->hidden->texturemem_size = width * height * bytes_per_pixel;
+
+	this->hidden->texturemem = memalign(32, this->hidden->texturemem_size);
+	if (this->hidden->texturemem == NULL)
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		SDL_SetError("Couldn't allocate memory for texture");
+		return NULL;
+	}
+
+	// Allocate the new pixel format for the screen
+	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		free(this->hidden->texturemem);
+		this->hidden->texturemem = NULL;
+
+		SDL_UnlockMutex(videomutex);
+		SDL_SetError("Couldn't allocate new pixel format for requested mode");
+		return NULL;
+	}
+
+	// Clear the buffer
+	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
+	SDL_memset(this->hidden->texturemem, 0, this->hidden->texturemem_size);
+
+	// Set up the new mode framebuffer
+	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME);
+	// Our surface is always double buffered
+	current->flags |= SDL_PREALLOC | SDL_DOUBLEBUF;
+	current->w = width;
+	current->h = height;
+	current->pitch = current->w * bytes_per_pixel;
+	current->pixels = this->hidden->buffer;
+
+	/* Set the hidden data */
+	this->hidden->width = current->w;
+	this->hidden->height = current->h;
+	this->hidden->pitch = current->w * (bytes_per_pixel > 2 ? 4 : bytes_per_pixel);
+
+	currentwidth = current->w;
+	currentheight = current->h;
+	currentbpp = bpp;
+	vresx = currentwidth;
+	vresy = currentheight;
+
+	GAMECUBE_VideoStart(this->hidden);
+
+	return current;
+}
+
+/* We don't actually allow hardware surfaces other than the main one */
+static int GAMECUBE_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+
+static void GAMECUBE_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static int GAMECUBE_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+
+static void GAMECUBE_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color;
+	*(truc + offset + 1) = color >> 24;
+	*(truc + offset + 32) = color >> 16;
+	*(truc + offset + 33) = color >> 8;
+}
+
+static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color >> 8;
+	*(truc + offset + 1) = color;
+}
+
+static inline void Set_PalPixel(_THIS, int x, int y, u8 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->pitch;
+	u32 offset;
+
+	offset = ((y & ~3) * width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+	truc[offset] = color;
+}
+
+static void UpdateRect_8(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 color;
+	int i, j;
+
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + rect->x);
+		for (j = 0; j < rect->w; j++)
+		{
+			color = src[j];
+			Set_PalPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_16(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u16 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 2 * (i + rect->y)) + (rect->x * 2));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 2);
+			color = (ptr[0] << 8) | ptr[1];
+			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_24(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 3 * (i + rect->y)) + (rect->x * 3));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 3);
+			color = (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | 0xff;
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_32(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 4 * (i + rect->y)) + (rect->x * 4));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 4);
+			color = (ptr[1] << 24) | (ptr[2] << 16) | (ptr[3] << 8) | ptr[0];
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
+{
+	int h, w;
+	long long int *dst = (long long int *) this->hidden->texturemem;
+	long long int *src1 = (long long int *) this->hidden->buffer;
+	long long int *src2 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 1));
+	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
+	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
+	int rowpitch = (this->hidden->pitch >> 3) * 3;
+
+	SDL_mutexP(videomutex);
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < this->hidden->pitch; w += 8)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 = src4;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+	}
+	SDL_CondSignal(videocond);
+	SDL_mutexV(videomutex);
+}
+
+static void GAMECUBE_UpdateRect(_THIS, SDL_Rect *rect)
+{
+	const SDL_Surface* const screen = this->screen;
+
+	switch(screen->format->BytesPerPixel) {
+	case 1:
+		UpdateRect_8(this, rect);
+		break;
+	case 2:
+		UpdateRect_16(this, rect);
+		break;
+	case 3:
+		UpdateRect_24(this, rect);
+		break;
+	case 4:
+		UpdateRect_32(this, rect);
+		break;
+	default:
+		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
+		break;
+	}
+}
+
+static void GAMECUBE_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+	int i;
+
+	// note that this function doesn't lock - we don't care if this isn't
+	// rendered now, that's what Flip is for
+
+	for (i = 0; i < numrects; i++)
+	{
+		GAMECUBE_UpdateRect(this, rects+i);
+	}
+
+	SDL_CondSignal(videocond);
+}
+
+static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	GAMECUBE_UpdateRects(this, 1, &screen_rect);
+}
+
+static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	GAMECUBE_UpdateRects(this, 1, &screen_rect);
+}
+
+static int GAMECUBE_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+	switch(surface->format->BytesPerPixel)
+	{
+		case 1:
+		case 2:
+			// 8 and 16 bit use the same tile format
+			flipHWSurface_16_16(this, surface);
+			break;
+		case 3:
+			flipHWSurface_24_16(this, surface);
+			break;
+		case 4:
+			flipHWSurface_32_16(this, surface);
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int GAMECUBE_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
+{
+	const int last_color = first_color + color_count;
+	Uint16* const palette = this->hidden->palette;
+	int     component;
+
+	SDL_LockMutex(videomutex);
+
+	/* Build the RGB24 palette. */
+	for (component = first_color; component != last_color; ++component, ++colors)
+	{
+		palette[component] = (colors->g << 8) | colors->r;
+		palette[component+256] = colors->b;
+	}
+
+	DCStoreRangeNoSync(palette+first_color, color_count*sizeof(Uint16));
+	DCStoreRange(palette+first_color+256, color_count*sizeof(Uint16));
+	GX_LoadTlut(&texpalette_a, GX_TLUT0);
+	GX_LoadTlut(&texpalette_b, GX_TLUT1);
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);
+	GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+	SDL_UnlockMutex(videomutex);
+
+	return(1);
+}
+
+static void GAMECUBE_VideoQuit(_THIS)
+{
+	WII_VideoStop();
+	GX_AbortFrame();
+	GX_Flush();
+
+	current = NULL;
+
+	VIDEO_SetBlack(TRUE);
+	VIDEO_Flush();
+
+	free(this->hidden->buffer);
+	this->hidden->buffer = NULL;
+	free(this->hidden->texturemem);
+	this->hidden->texturemem = NULL;
+}
+
+static void GAMECUBE_DeleteDevice(SDL_VideoDevice *device)
+{
+	free(device->hidden);
+	SDL_free(device);
+
+	SDL_DestroyCond(videocond);
+	videocond = 0;
+	SDL_DestroyMutex(videomutex);
+	videomutex=0;
+}
+
+static SDL_VideoDevice *GAMECUBE_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+			memalign(32, sizeof(struct SDL_PrivateVideoData));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( device ) {
+			SDL_free(device);
+		}
+		return(0);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+	videomutex = SDL_CreateMutex();
+	videocond = SDL_CreateCond();
+
+	/* Set the function pointers */
+	device->VideoInit = GAMECUBE_VideoInit;
+	device->ListModes = GAMECUBE_ListModes;
+	device->SetVideoMode = GAMECUBE_SetVideoMode;
+	device->SetColors = GAMECUBE_SetColors;
+	device->UpdateRects = GAMECUBE_UpdateRects;
+	device->VideoQuit = GAMECUBE_VideoQuit;
+	device->AllocHWSurface = GAMECUBE_AllocHWSurface;
+	device->LockHWSurface = GAMECUBE_LockHWSurface;
+	device->UnlockHWSurface = GAMECUBE_UnlockHWSurface;
+	device->FlipHWSurface = GAMECUBE_FlipHWSurface;
+	device->FreeHWSurface = GAMECUBE_FreeHWSurface;
+	device->input_grab = SDL_GRAB_ON;
+
+	device->free = GAMECUBE_DeleteDevice;
+
+	GAMECUBE_InitVideoSystem();
+	return device;
+}
+
+static int GAMECUBE_Available(void)
+{
+	return(1);
+}
+
+VideoBootStrap GAMECUBE_bootstrap = {
+	GAMECUBEVID_DRIVER_NAME, "Gamecube video driver",
+	GAMECUBE_Available, GAMECUBE_CreateDevice
+};
+
+void
+GAMECUBE_InitVideoSystem()
+{
+	/* Initialise the video system */
+	VIDEO_Init();
+	vmode = VIDEO_GetPreferredMode(NULL);
+
+	/* Set up the video system with the chosen mode */
+	if (vmode == &TVPal528IntDf)
+		vmode = &TVPal576IntDfScale;
+
+	VIDEO_Configure(vmode);
+
+	// Allocate the video buffer
+	if (xfb) free(MEM_K1_TO_K0(xfb));
+	xfb = (unsigned char*) MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+
+	VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+	VIDEO_SetNextFramebuffer(xfb);
+
+	// Show the screen.
+	VIDEO_SetBlack(FALSE);
+	VIDEO_Flush();
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
+
+	//CON_Init(xfb,20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
+
+	/*** Clear out FIFO area ***/
+	memset(&gp_fifo, 0, DEFAULT_FIFO_SIZE);
+
+	/*** Initialise GX ***/
+	GX_Init(&gp_fifo, DEFAULT_FIFO_SIZE);
+
+	GXColor background = { 0, 0, 0, 0xff };
+	GX_SetCopyClear (background, GX_MAX_Z24);
+
+	SetupGX();
+}
+
+void GAMECUBE_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
+{
+	square[6] = square[3]  =  xscale + xshift;
+	square[0] = square[9]  = -xscale + xshift;
+	square[4] = square[1]  =  yscale - yshift;
+	square[7] = square[10] = -yscale - yshift;
+	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
+	GX_InvVtxCache();
+}
diff --git a/src/video/gamecube/SDL_gamecube_video.h b/src/video/gamecube/SDL_gamecube_video.h
new file mode 100644
index 000000000..da033eff3
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_video.h
@@ -0,0 +1,57 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Tantric, 2009
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_gamecube_video_h
+#define _SDL_gamecube_video_h
+
+/* SDL internal includes */
+#include "../SDL_sysvideo.h"
+
+/* OGC includes */
+#include <ogc/gx_struct.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_VideoDevice *this
+
+/* Private display data */
+typedef struct SDL_PrivateVideoData
+{
+    // 2x256x16bit palettes = 1x256x24(32)bit palette
+    // first 256 entries are for Red/Green
+    // last 256 entries are for Green
+    Uint16 palette[2*256];
+
+    Uint8* buffer;
+
+    // these two fields MUST be in this order
+    Uint8* texturemem;
+    size_t texturemem_size;
+
+    int    width;
+    int    height;
+    int    pitch;
+} GamecubeVideo;
+
+void GAMECUBE_InitVideoSystem();
+void GAMECUBE_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
+
+#endif /* _SDL_wiivideo_h */
-- 
2.30.2


From aa3e55eb5703df8b340ab39c499bd84139fa5f7f Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Wed, 17 Jun 2020 01:46:34 +0100
Subject: [PATCH 15/24] add gamecube joystick

---
 include/SDL_config.h.in                 |   1 +
 src/joystick/gamecube/SDL_sysjoystick.c | 240 ++++++++++++++++++++++++
 2 files changed, 241 insertions(+)
 create mode 100644 src/joystick/gamecube/SDL_sysjoystick.c

diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 3a33531f7..f85aad30c 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -217,6 +217,7 @@
 #undef SDL_JOYSTICK_OS2
 #undef SDL_JOYSTICK_RISCOS
 #undef SDL_JOYSTICK_WII
+#undef SDL_JOYSTICK_GAMECUBE
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
diff --git a/src/joystick/gamecube/SDL_sysjoystick.c b/src/joystick/gamecube/SDL_sysjoystick.c
new file mode 100644
index 000000000..9709c5e47
--- /dev/null
+++ b/src/joystick/gamecube/SDL_sysjoystick.c
@@ -0,0 +1,240 @@
+/*
+ SDL - Simple DirectMedia Layer
+ Copyright (C) 1997-2006 Sam Lantinga
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Sam Lantinga
+ slouken@libsdl.org
+ */
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_GAMECUBE
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <gccore.h>
+#include <unistd.h>
+#include <math.h>
+
+#define MAX_GC_JOYSTICKS	4
+#define MAX_JOYSTICKS		MAX_GC_JOYSTICKS
+
+#define MAX_GC_AXES			6
+#define MAX_GC_BUTTONS		8
+#define	MAX_GC_HATS			1
+
+#define	JOYNAMELEN			10
+
+#define AXIS_MIN	-32767  /* minimum value for axis coordinate */
+#define AXIS_MAX	32767   /* maximum value for axis coordinate */
+
+typedef struct joystick_paddata_t
+{
+	u16 prev_buttons;
+	s8 stickX;
+	s8 stickY;
+	s8 substickX;
+	s8 substickY;
+	u8 triggerL;
+	u8 triggerR;
+}joystick_paddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata_t
+{
+	int index;
+	int type;
+	joystick_paddata gamecube;
+} joystick_hwdata;
+
+static const u16 sdl_buttons_gc[] =
+{
+	PAD_BUTTON_A,
+	PAD_BUTTON_B,
+	0 /* 1 */,
+	0 /* 2 */,
+	0 /* - */,
+	PAD_TRIGGER_Z,
+	PAD_BUTTON_START,
+	0 /* Z */,
+	0 /* C */,
+	PAD_BUTTON_X,
+	PAD_BUTTON_Y,
+	PAD_TRIGGER_L,
+	PAD_TRIGGER_R
+};
+
+static const int __numgcjoysticks = 4;
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	return 4;
+}
+
+static char joy_name[] = "Gamecube 0";
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	if(index>=0) {
+
+		if(index < 4 && index < __numgcjoysticks)
+			sprintf(joy_name, "Gamecube %d", index);
+	}
+	return (const char *)joy_name;
+}
+
+/* Function to open a joystick for use.
+ The joystick to open is specified by the index field of the joystick.
+ This should fill the nbuttons and naxes fields of the joystick structure.
+ It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	/* allocate memory for system specific hardware data */
+	joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+	if (joystick->hwdata == NULL)
+	{
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+
+	if(joystick->index < __numgcjoysticks)
+	{
+		((joystick_hwdata*)(joystick->hwdata))->index = joystick->index;
+		((joystick_hwdata*)(joystick->hwdata))->type = 1;
+		joystick->nbuttons = MAX_GC_BUTTONS;
+		joystick->naxes = MAX_GC_AXES;
+		joystick->nhats = MAX_GC_HATS;
+	}
+	return(0);
+}
+
+static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
+{
+	u16 buttons, prev_buttons, changed;
+	int i;
+	int axis;
+	joystick_hwdata *prev_state;
+	int index = joystick->index - 4;
+
+	buttons = PAD_ButtonsHeld(index);
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->gamecube.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP))
+	{
+		int hat = SDL_HAT_CENTERED;
+		if(buttons & PAD_BUTTON_UP) hat |= SDL_HAT_UP;
+		if(buttons & PAD_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+		if(buttons & PAD_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+		if(buttons & PAD_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++)
+	{
+		if (changed & sdl_buttons_gc[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->gamecube.prev_buttons = buttons;
+	axis = PAD_StickX(index);
+	if(prev_state->gamecube.stickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+		prev_state->gamecube.stickX = axis;
+	}
+
+	axis = PAD_StickY(index);
+	if(prev_state->gamecube.stickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+		prev_state->gamecube.stickY = axis;
+	}
+
+	axis = PAD_SubStickX(index);
+	if(prev_state->gamecube.substickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+		prev_state->gamecube.substickX = axis;
+	}
+
+	axis = PAD_SubStickY(index);
+	if(prev_state->gamecube.substickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+		prev_state->gamecube.substickY = axis;
+	}
+
+	axis = PAD_TriggerL(index);
+	if(prev_state->gamecube.triggerL != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
+		prev_state->gamecube.triggerL = axis;
+	}
+
+	axis = PAD_TriggerR(index);
+	if(prev_state->gamecube.triggerR != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
+		prev_state->gamecube.triggerR = axis;
+	}
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata)
+		return;
+
+	PAD_ScanPads();
+
+	_HandleGCJoystickUpdate(joystick);
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata) // joystick already closed
+		return;
+
+	SDL_free(joystick->hwdata);
+	joystick->hwdata = NULL;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+
+}
+
+#endif /* SDL_JOYSTICK_DC */
-- 
2.30.2


From 08edf9af84c026ba9c8cd0149fee2a0d8d74ef64 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Wed, 17 Jun 2020 01:49:43 +0100
Subject: [PATCH 16/24] gamecube configury

---
 configure.in | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/configure.in b/configure.in
index c7cf0954c..461ee43e2 100644
--- a/configure.in
+++ b/configure.in
@@ -964,6 +964,45 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
     fi
 }
 
+CheckNintendoGamecube()
+{
+    AC_ARG_ENABLE(nintendo-gamecube,
+AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintendo Gamecube [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_gamecube = xyes; then
+        ARCH=nintendo-gamecube
+        GAMECUBE_CFLAGS="-mogc -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/gamecube/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $GAMECUBE_CFLAGS"
+        CFLAGS="$CFLAGS $GAMECUBE_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $GAMECUBE_CFLAGS"
+        SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/gamecube/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/cube -logc"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_GAMECUBE)
+        SOURCES="$SOURCES $srcdir/src/joystick/gamecube/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_GAMECUBE)
+        SOURCES="$SOURCES $srcdir/src/video/gamecube/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/gamecube/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -2355,6 +2394,7 @@ dnl Set up the configuration based on the host platform!
 case "$host" in
     powerpc-*-eabi)
        CheckNintendoWii
+       CheckNintendoGamecube
        ;;
     arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
         ARCH=linux
-- 
2.30.2


From 1d633a60242e6c40f6aa04f52c983893d4d006c1 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Fri, 19 Jun 2020 18:44:04 +0100
Subject: [PATCH 17/24] cube/wii make sdl-config supply all libs

---
 configure.in | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/configure.in b/configure.in
index 461ee43e2..fcd878c95 100644
--- a/configure.in
+++ b/configure.in
@@ -942,8 +942,8 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
         SDL_CFLAGS="$SDL_CFLAGS $WII_CFLAGS"
         SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
                   -L${DEVKITPRO}/portlibs/wii/lib \
-                  -L${DEVKITPRO}/portlibs/ppc/lib $SDL_LIBS \
-                  -L${DEVKITPRO}/libogc/lib/wii -logc"
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/wii -laesnd -lwiiuse -lbte -lwiikeyboard -lfat -logc -lm"
         AC_DEFINE(SDL_TIMER_OGC)
         SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
         have_timers=yes
@@ -981,8 +981,8 @@ AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintend
         SDL_CFLAGS="$SDL_CFLAGS $GAMECUBE_CFLAGS"
         SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
                   -L${DEVKITPRO}/portlibs/gamecube/lib \
-                  -L${DEVKITPRO}/portlibs/ppc/lib $SDL_LIBS \
-                  -L${DEVKITPRO}/libogc/lib/cube -logc"
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/cube -laesnd -lfat -logc -lm"
         AC_DEFINE(SDL_TIMER_OGC)
         SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
         have_timers=yes
-- 
2.30.2


From 1130e0cabbe8f41c33d8af311ee5feeb4cbb3af9 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Fri, 19 Jun 2020 18:47:02 +0100
Subject: [PATCH 18/24] gamecube: link with correct options

---
 configure.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.in b/configure.in
index fcd878c95..9b1d5251e 100644
--- a/configure.in
+++ b/configure.in
@@ -979,7 +979,7 @@ AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintend
         EXTRA_CFLAGS="$EXTRA_CFLAGS $GAMECUBE_CFLAGS"
         CFLAGS="$CFLAGS $GAMECUBE_CFLAGS"
         SDL_CFLAGS="$SDL_CFLAGS $GAMECUBE_CFLAGS"
-        SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
+        SDL_LIBS="-mogc -mcpu=750 -meabi -mhard-float \
                   -L${DEVKITPRO}/portlibs/gamecube/lib \
                   -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS \
                   -L${DEVKITPRO}/libogc/lib/cube -laesnd -lfat -logc -lm"
-- 
2.30.2


From 950129eca2aab9a3f260fac949ebf050733f205b Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Sat, 20 Jun 2020 16:00:37 +0100
Subject: [PATCH 19/24] use devkitPPC defines

---
 include/SDL_main.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/SDL_main.h b/include/SDL_main.h
index bc5142773..9824c5063 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -33,7 +33,7 @@
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
     defined(__SYMBIAN32__) || defined(QWS) || \
-    defined(__WII__) || defined(__GAMECUBE__)
+    defined(__wii__) || defined(__gamecube__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
-- 
2.30.2


From b96ec73ac2d7d605daa51e055e3c1c490fbcd2e5 Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Sat, 20 Jun 2020 17:43:15 +0100
Subject: [PATCH 20/24] consolidate wii & cube video

---
 configure.in                                  |   6 +-
 include/SDL_config.h.in                       |   3 +-
 src/main/gamecube/SDL_gamecube_main.c         |   8 +-
 src/main/wii/SDL_wii_main.c                   |   8 +-
 src/video/SDL_sysvideo.h                      |   4 +-
 src/video/SDL_video.c                         |   4 +-
 src/video/gamecube/SDL_gamecube_events.c      |  13 +
 src/video/gamecube/SDL_gamecube_events_c.h    |   4 +
 src/video/gamecube/SDL_gamecube_mouse.c       |   8 +
 src/video/gamecube/SDL_gamecube_video.c       | 818 ------------------
 src/video/gamecube/SDL_gamecube_video.h       |  57 --
 .../SDL_wiivideo.c => ogc/SDL_ogc_video.c}    | 121 ++-
 src/video/ogc/SDL_ogc_video.h                 |  37 +
 src/video/wii/SDL_wiievents.c                 |   1 -
 src/video/wii/SDL_wiievents_c.h               |   2 +-
 src/video/wii/SDL_wiimouse_c.h                |   2 +-
 src/video/wii/SDL_wiivideo.h                  |  57 --
 17 files changed, 154 insertions(+), 999 deletions(-)
 create mode 100644 src/video/gamecube/SDL_gamecube_events.c
 create mode 100644 src/video/gamecube/SDL_gamecube_events_c.h
 create mode 100644 src/video/gamecube/SDL_gamecube_mouse.c
 delete mode 100644 src/video/gamecube/SDL_gamecube_video.c
 delete mode 100644 src/video/gamecube/SDL_gamecube_video.h
 rename src/video/{wii/SDL_wiivideo.c => ogc/SDL_ogc_video.c} (85%)
 create mode 100644 src/video/ogc/SDL_ogc_video.h
 delete mode 100644 src/video/wii/SDL_wiivideo.h

diff --git a/configure.in b/configure.in
index 9b1d5251e..a7dfa47b0 100644
--- a/configure.in
+++ b/configure.in
@@ -956,8 +956,9 @@ AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii
         AC_DEFINE(SDL_THREAD_OGC)
         SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
         have_threads=yes
-        AC_DEFINE(SDL_VIDEO_DRIVER_WII)
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
         SOURCES="$SOURCES $srcdir/src/video/wii/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
         SDLMAIN_SOURCES="$srcdir/src/main/wii/*.c"
         SDLMAIN_LDFLAGS="-static"
         have_video=yes
@@ -995,8 +996,9 @@ AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintend
         AC_DEFINE(SDL_THREAD_OGC)
         SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
         have_threads=yes
-        AC_DEFINE(SDL_VIDEO_DRIVER_GAMECUBE)
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
         SOURCES="$SOURCES $srcdir/src/video/gamecube/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
         SDLMAIN_SOURCES="$srcdir/src/main/gamecube/*.c"
         SDLMAIN_LDFLAGS="-static"
         have_video=yes
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index f85aad30c..212f2cf67 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -284,8 +284,7 @@
 #undef SDL_VIDEO_DRIVER_SVGALIB
 #undef SDL_VIDEO_DRIVER_TOOLBOX
 #undef SDL_VIDEO_DRIVER_VGL
-#undef SDL_VIDEO_DRIVER_WII
-#undef SDL_VIDEO_DRIVER_GAMECUBE
+#undef SDL_VIDEO_DRIVER_OGC
 #undef SDL_VIDEO_DRIVER_WINDIB
 #undef SDL_VIDEO_DRIVER_WSCONS
 #undef SDL_VIDEO_DRIVER_X11
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
index 51b5fd3d2..fbbd91334 100644
--- a/src/main/gamecube/SDL_gamecube_main.c
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -6,7 +6,7 @@
 #include <stdio.h>
 
 /* SDL includes */
-#include "../../video/gamecube/SDL_gamecube_video.h"
+#include "../../video/ogc/SDL_ogc_video.h"
 
 /* OGC includes */
 #include <fat.h>
@@ -18,9 +18,13 @@ int main(int argc, char *argv[])
 {
 //	SYS_SetPowerCallback(ShutdownCB);
 //	SYS_SetResetCallback(ResetCB);
+	printf("PAD Init\n");
 	PAD_Init();
-	GAMECUBE_InitVideoSystem();
+	printf("video init\n");
+	OGC_InitVideoSystem();
+	printf("fat init\n");
 	fatInitDefault();
 	/* Call the user's main function */
+	printf("call main\n");
 	return(SDL_main(argc, argv));
 }
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
index 1a8935908..741b184a8 100644
--- a/src/main/wii/SDL_wii_main.c
+++ b/src/main/wii/SDL_wii_main.c
@@ -6,7 +6,7 @@
 #include <stdio.h>
 
 /* SDL includes */
-#include "../../video/wii/SDL_wiivideo.h"
+#include "../../video/ogc/SDL_ogc_video.h"
 
 /* OGC includes */
 #include <fat.h>
@@ -52,7 +52,6 @@ void Terminate()
 /* Entry point */
 int main(int argc, char *argv[])
 {
-#ifdef HW_RVL
 	L2Enhance();
 	u32 version = IOS_GetVersion();
 	s32 preferred = IOS_GetPreferredVersion();
@@ -65,16 +64,13 @@ int main(int argc, char *argv[])
 	WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
 	SYS_SetPowerCallback(ShutdownCB);
 	SYS_SetResetCallback(ResetCB);
-#endif
 	PAD_Init();
-	WII_InitVideoSystem();
-#ifdef HW_RVL
+	OGC_InitVideoSystem();
 	WPAD_SetDataFormat(WPAD_CHAN_ALL,WPAD_FMT_BTNS_ACC_IR);
 	WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
 
 	MOUSE_Init();
 	KEYBOARD_Init(NULL);
-#endif
     fatInitDefault();
 	/* Call the user's main function */
 	return(SDL_main(argc, argv));
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index fd110e79f..65d56a56b 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -410,8 +410,8 @@ extern VideoBootStrap AALIB_bootstrap;
 #if SDL_VIDEO_DRIVER_CACA
 extern VideoBootStrap CACA_bootstrap;
 #endif
-#if SDL_VIDEO_DRIVER_WII
-extern VideoBootStrap WII_bootstrap;
+#if SDL_VIDEO_DRIVER_OGC
+extern VideoBootStrap OGC_bootstrap;
 #endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index a2441b75e..bf379f4b6 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -126,8 +126,8 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_CACA
 	&CACA_bootstrap,
 #endif
-#if SDL_VIDEO_DRIVER_WII
-	&WII_bootstrap,
+#if SDL_VIDEO_DRIVER_OGC
+	&OGC_bootstrap,
 #endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
diff --git a/src/video/gamecube/SDL_gamecube_events.c b/src/video/gamecube/SDL_gamecube_events.c
new file mode 100644
index 000000000..e44a84a9e
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events.c
@@ -0,0 +1,13 @@
+#include "SDL_config.h"
+
+
+#include "SDL.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+
+#include "../ogc/SDL_ogc_video.h"
+#include "SDL_gamecube_events_c.h"
+
+void GAMECUBE_PumpEvents(_THIS) {}
+
+void GAMECUBE_InitOSKeymap(_THIS) {}
diff --git a/src/video/gamecube/SDL_gamecube_events_c.h b/src/video/gamecube/SDL_gamecube_events_c.h
new file mode 100644
index 000000000..5084d26f5
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events_c.h
@@ -0,0 +1,4 @@
+#include "SDL_config.h"
+
+extern void GAMECUBE_InitOSKeymap(_THIS);
+extern void GAMECUBE_PumpEvents(_THIS);
diff --git a/src/video/gamecube/SDL_gamecube_mouse.c b/src/video/gamecube/SDL_gamecube_mouse.c
new file mode 100644
index 000000000..9511d820b
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_mouse.c
@@ -0,0 +1,8 @@
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/gamecube/SDL_gamecube_video.c b/src/video/gamecube/SDL_gamecube_video.c
deleted file mode 100644
index a3a939d98..000000000
--- a/src/video/gamecube/SDL_gamecube_video.c
+++ /dev/null
@@ -1,818 +0,0 @@
-/*
-	SDL - Simple DirectMedia Layer
-	Copyright (C) 1997-2006 Sam Lantinga
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-	Tantric, 2009
-*/
-#include "SDL_config.h"
-
-// Standard includes.
-#include <math.h>
-
-// SDL internal includes.
-#include "../SDL_sysvideo.h"
-#include "../SDL_pixels_c.h"
-#include "SDL_timer.h"
-#include "SDL_thread.h"
-
-// SDL Gamecube specifics.
-#include <gccore.h>
-#include <ogcsys.h>
-#include <malloc.h>
-#include "SDL_gamecube_video.h"
-#include <ogc/machine/processor.h>
-
-static const char	GAMECUBEVID_DRIVER_NAME[] = "gamecube";
-static lwp_t videothread = LWP_THREAD_NULL;
-static SDL_mutex *videomutex = NULL;
-static SDL_cond *videocond = NULL;
-static GamecubeVideo *current = NULL;
-
-int vresx=0, vresy=0;
-
-/*** SDL ***/
-static SDL_Rect mode_320, mode_640;
-
-static SDL_Rect* modes_descending[] =
-{
-	&mode_640,
-	&mode_320,
-	NULL
-};
-
-/*** 2D Video ***/
-#define HASPECT 			320
-#define VASPECT 			240
-
-unsigned char *xfb = NULL;
-GXRModeObj* vmode = 0;
-static int quit_flip_thread = 0;
-static GXTexObj texobj_a, texobj_b;
-static GXTlutObj texpalette_a, texpalette_b;
-
-/*** GX ***/
-#define DEFAULT_FIFO_SIZE 256 * 1024
-static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
-
-/* New texture based scaler */
-typedef struct tagcamera
-{
-	guVector pos;
-	guVector up;
-	guVector view;
-}
-camera;
-
-/*** Square Matrix
-     This structure controls the size of the image on the screen.
-	 Think of the output as a -80 x 80 by -60 x 60 graph.
-***/
-static s16 square[] ATTRIBUTE_ALIGN (32) =
-{
-  /*
-   * X,   Y,  Z
-   * Values set are for roughly 4:3 aspect
-   */
-	-HASPECT,  VASPECT, 0,	// 0
-	 HASPECT,  VASPECT, 0,	// 1
-	 HASPECT, -VASPECT, 0,	// 2
-	-HASPECT, -VASPECT, 0	// 3
-};
-
-static const f32 tex_pos[] ATTRIBUTE_ALIGN(32) = {
-	0.0, 0.0,
-	1.0, 0.0,
-	1.0, 1.0,
-	0.0, 1.0,
-};
-
-static camera cam = {
-	{0.0F, 0.0F, 0.0F},
-	{0.0F, 0.5F, 0.0F},
-	{0.0F, 0.0F, -0.5F}
-};
-
-/****************************************************************************
- * Scaler Support Functions
- ***************************************************************************/
-static int currentwidth;
-static int currentheight;
-static int currentbpp;
-
-static void
-draw_init(void *palette, void *tex)
-{
-	Mtx m, mv, view;
-
-	GX_ClearVtxDesc ();
-	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
-	GX_SetVtxDesc (GX_VA_TEX0, GX_INDEX8);
-
-	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
-	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
-
-	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
-	GX_SetArray (GX_VA_TEX0, (void*)tex_pos, 2 * sizeof (f32));
-	GX_SetNumTexGens (1);
-	GX_SetNumChans (0);
-
-	GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
-
-	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
-	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
-
-	memset(&view, 0, sizeof (Mtx));
-	guLookAt(view, &cam.pos, &cam.up, &cam.view);
-	guMtxIdentity(m);
-	guMtxTransApply(m, m, 0, 0, -100);
-	guMtxConcat(view, m, mv);
-	GX_LoadPosMtxImm(mv, GX_PNMTX0);
-
-	GX_InvVtxCache ();	// update vertex cache
-
-	if (currentbpp == 8) {
-		GX_InitTlutObj(&texpalette_a, palette, GX_TL_IA8, 256);
-		GX_InitTlutObj(&texpalette_b, (Uint16*)palette+256, GX_TL_IA8, 256);
-		DCStoreRange(palette, sizeof(512*sizeof(Uint16)));
-		GX_LoadTlut(&texpalette_a, GX_TLUT0);
-		GX_LoadTlut(&texpalette_b, GX_TLUT1);
-
-		GX_InitTexObjCI(&texobj_a, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
-		GX_InitTexObjCI(&texobj_b, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
-		GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
-
-		// Setup TEV to combine Red+Green and Blue paletted images
-		GX_SetTevColor(GX_TEVREG0, (GXColor){255, 255, 0, 0});
-		GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
-		GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
-		// first stage = red and green
-		GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
-		GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
-		// second stage = add blue (and opaque alpha)
-		GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
-		GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
-		GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
-		GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
-		GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
-
-		GX_SetNumTevStages(2);
-	}
-	else if (currentbpp == 16)
-		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
-	else
-		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
-
-	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);	// load texture object so its ready to use
-}
-
-static inline void
-draw_vert (u8 index)
-{
-	GX_Position1x8 (index);
-	GX_TexCoord1x8 (index);
-}
-
-static inline void
-draw_square ()
-{
-	GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
-	draw_vert(0);
-	draw_vert(1);
-	draw_vert(2);
-	draw_vert(3);
-	GX_End();
-}
-
-static void * flip_thread (void *arg)
-{
-	u32 *tex = (u32*)arg;
-
-	GX_SetCurrentGXThread();
-
-	// clear EFB
-	GX_CopyDisp(xfb, GX_TRUE);
-
-	SDL_mutexP(videomutex);
-
-	while(!quit_flip_thread)
-	{
-		// update texture
-		DCStoreRange((void*)tex[0], tex[1]);
-		// clear texture objects
-		GX_InvalidateTexAll();
-		draw_square(); // render textured quad
-
-		VIDEO_WaitVSync();
-		GX_CopyDisp(xfb, GX_FALSE);
-
-		GX_DrawDone();
-
-		SDL_CondWait(videocond, videomutex);
-	}
-	SDL_mutexV(videomutex);
-
-	return NULL;
-}
-
-static void
-SetupGX()
-{
-	Mtx44 p;
-	int df = 1; // deflicker on/off
-
-	GX_SetCurrentGXThread();
-	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
-	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
-	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
-
-	GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
-	GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
-	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
-
-	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
-	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
-	GX_SetDispCopyGamma (GX_GM_1_0);
-	GX_SetCullMode (GX_CULL_NONE);
-	GX_SetBlendMode(GX_BM_NONE,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
-
-	GX_SetZMode (GX_FALSE, GX_LEQUAL, GX_TRUE);
-	GX_SetColorUpdate (GX_TRUE);
-	GX_SetAlphaUpdate(GX_FALSE);
-
-	guOrtho(p, VASPECT, -VASPECT, -HASPECT, HASPECT, 100, 1000); // matrix, t, b, l, r, n, f
-	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
-	GX_Flush();
-}
-
-static void
-StartVideoThread(void *args)
-{
-	if(videothread == LWP_THREAD_NULL)
-	{
-		quit_flip_thread = 0;
-		LWP_CreateThread(&videothread, flip_thread, args, NULL, 0, 68);
-	}
-}
-
-void GAMECUBE_VideoStart(GamecubeVideo *private)
-{
-	if (private==NULL) {
-		if (current==NULL)
-			return;
-		private = current;
-	}
-
-	SetupGX();
-	draw_init(private->palette, private->texturemem);
-	StartVideoThread(&private->texturemem);
-	current = private;
-}
-
-void WII_VideoStop()
-{
-	if(videothread == LWP_THREAD_NULL)
-		return;
-
-	SDL_LockMutex(videomutex);
-	quit_flip_thread = 1;
-	SDL_CondSignal(videocond);
-	SDL_UnlockMutex(videomutex);
-
-	LWP_JoinThread(videothread, NULL);
-	videothread = LWP_THREAD_NULL;
-}
-
-static int GAMECUBE_VideoInit(_THIS, SDL_PixelFormat *vformat)
-{
-	// Set up the modes.
-	mode_640.w = 640;
-	mode_640.h = 480;
-	mode_320.w = 320;
-	mode_320.h = 240;
-
-	// Set the current format.
-	vformat->BitsPerPixel	= 16;
-	vformat->BytesPerPixel	= 2;
-
-	this->hidden->buffer = NULL;
-	this->hidden->texturemem = NULL;
-	this->hidden->width = 0;
-	this->hidden->height = 0;
-	this->hidden->pitch = 0;
-
-	/* We're done! */
-	return 0;
-}
-
-static SDL_Rect **GAMECUBE_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
-{
-	return modes_descending;
-}
-
-static SDL_Surface *GAMECUBE_SetVideoMode(_THIS, SDL_Surface *current,
-								   int width, int height, int bpp, Uint32 flags)
-{
-	SDL_Rect* 		mode;
-	size_t			bytes_per_pixel;
-	Uint32			r_mask = 0;
-	Uint32			b_mask = 0;
-	Uint32			g_mask = 0;
-
-	// Find a mode big enough to store the requested resolution
-	mode = modes_descending[0];
-	while (mode)
-	{
-		if (mode->w == width && mode->h == height)
-			break;
-		else
-			++mode;
-	}
-
-	// Didn't find a mode?
-	if (!mode)
-	{
-		SDL_SetError("Display mode (%dx%d) is unsupported.",
-			width, height);
-		return NULL;
-	}
-
-	if(bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
-	{
-		SDL_SetError("Resolution (%d bpp) is unsupported (8/16/24/32 bpp only).",
-			bpp);
-		return NULL;
-	}
-
-	bytes_per_pixel = bpp / 8;
-
-	WII_VideoStop();
-
-	free(this->hidden->buffer);
-	free(this->hidden->texturemem);
-
-	// Allocate the new buffer.
-	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
-	if (!this->hidden->buffer )
-	{
-		this->hidden->texturemem = NULL;
-		SDL_SetError("Couldn't allocate buffer for requested mode");
-		return(NULL);
-	}
-
-	// Allocate texture memory
-	if (bytes_per_pixel > 2)
-		this->hidden->texturemem_size = width * height * 4;
-	else
-		this->hidden->texturemem_size = width * height * bytes_per_pixel;
-
-	this->hidden->texturemem = memalign(32, this->hidden->texturemem_size);
-	if (this->hidden->texturemem == NULL)
-	{
-		free(this->hidden->buffer);
-		this->hidden->buffer = NULL;
-		SDL_SetError("Couldn't allocate memory for texture");
-		return NULL;
-	}
-
-	// Allocate the new pixel format for the screen
-	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
-	{
-		free(this->hidden->buffer);
-		this->hidden->buffer = NULL;
-		free(this->hidden->texturemem);
-		this->hidden->texturemem = NULL;
-
-		SDL_UnlockMutex(videomutex);
-		SDL_SetError("Couldn't allocate new pixel format for requested mode");
-		return NULL;
-	}
-
-	// Clear the buffer
-	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
-	SDL_memset(this->hidden->texturemem, 0, this->hidden->texturemem_size);
-
-	// Set up the new mode framebuffer
-	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME);
-	// Our surface is always double buffered
-	current->flags |= SDL_PREALLOC | SDL_DOUBLEBUF;
-	current->w = width;
-	current->h = height;
-	current->pitch = current->w * bytes_per_pixel;
-	current->pixels = this->hidden->buffer;
-
-	/* Set the hidden data */
-	this->hidden->width = current->w;
-	this->hidden->height = current->h;
-	this->hidden->pitch = current->w * (bytes_per_pixel > 2 ? 4 : bytes_per_pixel);
-
-	currentwidth = current->w;
-	currentheight = current->h;
-	currentbpp = bpp;
-	vresx = currentwidth;
-	vresy = currentheight;
-
-	GAMECUBE_VideoStart(this->hidden);
-
-	return current;
-}
-
-/* We don't actually allow hardware surfaces other than the main one */
-static int GAMECUBE_AllocHWSurface(_THIS, SDL_Surface *surface)
-{
-	return(-1);
-}
-
-static void GAMECUBE_FreeHWSurface(_THIS, SDL_Surface *surface)
-{
-	return;
-}
-
-static int GAMECUBE_LockHWSurface(_THIS, SDL_Surface *surface)
-{
-	return(0);
-}
-
-static void GAMECUBE_UnlockHWSurface(_THIS, SDL_Surface *surface)
-{
-	return;
-}
-
-static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
-{
-	u8 *truc = this->hidden->texturemem;
-	int width = this->hidden->width;
-	u32 offset;
-
-	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + ((((y & 3) << 2) + (x & 3)) << 1);
-
-	*(truc + offset) = color;
-	*(truc + offset + 1) = color >> 24;
-	*(truc + offset + 32) = color >> 16;
-	*(truc + offset + 33) = color >> 8;
-}
-
-static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
-{
-	u8 *truc = this->hidden->texturemem;
-	int width = this->hidden->width;
-	u32 offset;
-
-	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + ((((y & 3) << 2) + (x & 3)) << 1);
-
-	*(truc + offset) = color >> 8;
-	*(truc + offset + 1) = color;
-}
-
-static inline void Set_PalPixel(_THIS, int x, int y, u8 color)
-{
-	u8 *truc = this->hidden->texturemem;
-	int width = this->hidden->pitch;
-	u32 offset;
-
-	offset = ((y & ~3) * width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
-
-	truc[offset] = color;
-}
-
-static void UpdateRect_8(_THIS, SDL_Rect *rect)
-{
-	u8 *src;
-	u8 color;
-	int i, j;
-
-	for (i = 0; i < rect->h; i++)
-	{
-		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + rect->x);
-		for (j = 0; j < rect->w; j++)
-		{
-			color = src[j];
-			Set_PalPixel(this, rect->x + j, rect->y + i, color);
-		}
-	}
-}
-
-static void UpdateRect_16(_THIS, SDL_Rect *rect)
-{
-	u8 *src;
-	u8 *ptr;
-	u16 color;
-	int i, j;
-	for (i = 0; i < rect->h; i++)
-	{
-		src = (this->hidden->buffer + (this->hidden->width * 2 * (i + rect->y)) + (rect->x * 2));
-		for (j = 0; j < rect->w; j++)
-		{
-			ptr = src + (j * 2);
-			color = (ptr[0] << 8) | ptr[1];
-			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
-		}
-	}
-}
-
-static void UpdateRect_24(_THIS, SDL_Rect *rect)
-{
-	u8 *src;
-	u8 *ptr;
-	u32 color;
-	int i, j;
-	for (i = 0; i < rect->h; i++)
-	{
-		src = (this->hidden->buffer + (this->hidden->width * 3 * (i + rect->y)) + (rect->x * 3));
-		for (j = 0; j < rect->w; j++)
-		{
-			ptr = src + (j * 3);
-			color = (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | 0xff;
-			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
-		}
-	}
-}
-
-static void UpdateRect_32(_THIS, SDL_Rect *rect)
-{
-	u8 *src;
-	u8 *ptr;
-	u32 color;
-	int i, j;
-	for (i = 0; i < rect->h; i++)
-	{
-		src = (this->hidden->buffer + (this->hidden->width * 4 * (i + rect->y)) + (rect->x * 4));
-		for (j = 0; j < rect->w; j++)
-		{
-			ptr = src + (j * 4);
-			color = (ptr[1] << 24) | (ptr[2] << 16) | (ptr[3] << 8) | ptr[0];
-			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
-		}
-	}
-}
-
-static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
-{
-	int h, w;
-	long long int *dst = (long long int *) this->hidden->texturemem;
-	long long int *src1 = (long long int *) this->hidden->buffer;
-	long long int *src2 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 1));
-	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
-	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
-	int rowpitch = (this->hidden->pitch >> 3) * 3;
-
-	SDL_mutexP(videomutex);
-	for (h = 0; h < this->hidden->height; h += 4)
-	{
-		for (w = 0; w < this->hidden->pitch; w += 8)
-		{
-			*dst++ = *src1++;
-			*dst++ = *src2++;
-			*dst++ = *src3++;
-			*dst++ = *src4++;
-		}
-
-		src1 = src4;
-		src2 += rowpitch;
-		src3 += rowpitch;
-		src4 += rowpitch;
-	}
-	SDL_CondSignal(videocond);
-	SDL_mutexV(videomutex);
-}
-
-static void GAMECUBE_UpdateRect(_THIS, SDL_Rect *rect)
-{
-	const SDL_Surface* const screen = this->screen;
-
-	switch(screen->format->BytesPerPixel) {
-	case 1:
-		UpdateRect_8(this, rect);
-		break;
-	case 2:
-		UpdateRect_16(this, rect);
-		break;
-	case 3:
-		UpdateRect_24(this, rect);
-		break;
-	case 4:
-		UpdateRect_32(this, rect);
-		break;
-	default:
-		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
-		break;
-	}
-}
-
-static void GAMECUBE_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
-{
-	int i;
-
-	// note that this function doesn't lock - we don't care if this isn't
-	// rendered now, that's what Flip is for
-
-	for (i = 0; i < numrects; i++)
-	{
-		GAMECUBE_UpdateRect(this, rects+i);
-	}
-
-	SDL_CondSignal(videocond);
-}
-
-static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
-{
-	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	GAMECUBE_UpdateRects(this, 1, &screen_rect);
-}
-
-static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
-{
-	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	GAMECUBE_UpdateRects(this, 1, &screen_rect);
-}
-
-static int GAMECUBE_FlipHWSurface(_THIS, SDL_Surface *surface)
-{
-	switch(surface->format->BytesPerPixel)
-	{
-		case 1:
-		case 2:
-			// 8 and 16 bit use the same tile format
-			flipHWSurface_16_16(this, surface);
-			break;
-		case 3:
-			flipHWSurface_24_16(this, surface);
-			break;
-		case 4:
-			flipHWSurface_32_16(this, surface);
-			break;
-		default:
-			return -1;
-	}
-	return 0;
-}
-
-static int GAMECUBE_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
-{
-	const int last_color = first_color + color_count;
-	Uint16* const palette = this->hidden->palette;
-	int     component;
-
-	SDL_LockMutex(videomutex);
-
-	/* Build the RGB24 palette. */
-	for (component = first_color; component != last_color; ++component, ++colors)
-	{
-		palette[component] = (colors->g << 8) | colors->r;
-		palette[component+256] = colors->b;
-	}
-
-	DCStoreRangeNoSync(palette+first_color, color_count*sizeof(Uint16));
-	DCStoreRange(palette+first_color+256, color_count*sizeof(Uint16));
-	GX_LoadTlut(&texpalette_a, GX_TLUT0);
-	GX_LoadTlut(&texpalette_b, GX_TLUT1);
-	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);
-	GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
-
-	SDL_UnlockMutex(videomutex);
-
-	return(1);
-}
-
-static void GAMECUBE_VideoQuit(_THIS)
-{
-	WII_VideoStop();
-	GX_AbortFrame();
-	GX_Flush();
-
-	current = NULL;
-
-	VIDEO_SetBlack(TRUE);
-	VIDEO_Flush();
-
-	free(this->hidden->buffer);
-	this->hidden->buffer = NULL;
-	free(this->hidden->texturemem);
-	this->hidden->texturemem = NULL;
-}
-
-static void GAMECUBE_DeleteDevice(SDL_VideoDevice *device)
-{
-	free(device->hidden);
-	SDL_free(device);
-
-	SDL_DestroyCond(videocond);
-	videocond = 0;
-	SDL_DestroyMutex(videomutex);
-	videomutex=0;
-}
-
-static SDL_VideoDevice *GAMECUBE_CreateDevice(int devindex)
-{
-	SDL_VideoDevice *device;
-
-	/* Initialize all variables that we clean on shutdown */
-	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
-	if ( device ) {
-		SDL_memset(device, 0, (sizeof *device));
-		device->hidden = (struct SDL_PrivateVideoData *)
-			memalign(32, sizeof(struct SDL_PrivateVideoData));
-	}
-	if ( (device == NULL) || (device->hidden == NULL) ) {
-		SDL_OutOfMemory();
-		if ( device ) {
-			SDL_free(device);
-		}
-		return(0);
-	}
-	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
-
-	videomutex = SDL_CreateMutex();
-	videocond = SDL_CreateCond();
-
-	/* Set the function pointers */
-	device->VideoInit = GAMECUBE_VideoInit;
-	device->ListModes = GAMECUBE_ListModes;
-	device->SetVideoMode = GAMECUBE_SetVideoMode;
-	device->SetColors = GAMECUBE_SetColors;
-	device->UpdateRects = GAMECUBE_UpdateRects;
-	device->VideoQuit = GAMECUBE_VideoQuit;
-	device->AllocHWSurface = GAMECUBE_AllocHWSurface;
-	device->LockHWSurface = GAMECUBE_LockHWSurface;
-	device->UnlockHWSurface = GAMECUBE_UnlockHWSurface;
-	device->FlipHWSurface = GAMECUBE_FlipHWSurface;
-	device->FreeHWSurface = GAMECUBE_FreeHWSurface;
-	device->input_grab = SDL_GRAB_ON;
-
-	device->free = GAMECUBE_DeleteDevice;
-
-	GAMECUBE_InitVideoSystem();
-	return device;
-}
-
-static int GAMECUBE_Available(void)
-{
-	return(1);
-}
-
-VideoBootStrap GAMECUBE_bootstrap = {
-	GAMECUBEVID_DRIVER_NAME, "Gamecube video driver",
-	GAMECUBE_Available, GAMECUBE_CreateDevice
-};
-
-void
-GAMECUBE_InitVideoSystem()
-{
-	/* Initialise the video system */
-	VIDEO_Init();
-	vmode = VIDEO_GetPreferredMode(NULL);
-
-	/* Set up the video system with the chosen mode */
-	if (vmode == &TVPal528IntDf)
-		vmode = &TVPal576IntDfScale;
-
-	VIDEO_Configure(vmode);
-
-	// Allocate the video buffer
-	if (xfb) free(MEM_K1_TO_K0(xfb));
-	xfb = (unsigned char*) MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
-
-	VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
-	VIDEO_SetNextFramebuffer(xfb);
-
-	// Show the screen.
-	VIDEO_SetBlack(FALSE);
-	VIDEO_Flush();
-	VIDEO_WaitVSync(); VIDEO_WaitVSync();
-
-	//CON_Init(xfb,20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
-
-	/*** Clear out FIFO area ***/
-	memset(&gp_fifo, 0, DEFAULT_FIFO_SIZE);
-
-	/*** Initialise GX ***/
-	GX_Init(&gp_fifo, DEFAULT_FIFO_SIZE);
-
-	GXColor background = { 0, 0, 0, 0xff };
-	GX_SetCopyClear (background, GX_MAX_Z24);
-
-	SetupGX();
-}
-
-void GAMECUBE_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
-{
-	square[6] = square[3]  =  xscale + xshift;
-	square[0] = square[9]  = -xscale + xshift;
-	square[4] = square[1]  =  yscale - yshift;
-	square[7] = square[10] = -yscale - yshift;
-	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
-	GX_InvVtxCache();
-}
diff --git a/src/video/gamecube/SDL_gamecube_video.h b/src/video/gamecube/SDL_gamecube_video.h
deleted file mode 100644
index da033eff3..000000000
--- a/src/video/gamecube/SDL_gamecube_video.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2006 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Tantric, 2009
-*/
-#include "SDL_config.h"
-
-#ifndef _SDL_gamecube_video_h
-#define _SDL_gamecube_video_h
-
-/* SDL internal includes */
-#include "../SDL_sysvideo.h"
-
-/* OGC includes */
-#include <ogc/gx_struct.h>
-
-/* Hidden "this" pointer for the video functions */
-#define _THIS   SDL_VideoDevice *this
-
-/* Private display data */
-typedef struct SDL_PrivateVideoData
-{
-    // 2x256x16bit palettes = 1x256x24(32)bit palette
-    // first 256 entries are for Red/Green
-    // last 256 entries are for Green
-    Uint16 palette[2*256];
-
-    Uint8* buffer;
-
-    // these two fields MUST be in this order
-    Uint8* texturemem;
-    size_t texturemem_size;
-
-    int    width;
-    int    height;
-    int    pitch;
-} GamecubeVideo;
-
-void GAMECUBE_InitVideoSystem();
-void GAMECUBE_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
-
-#endif /* _SDL_wiivideo_h */
diff --git a/src/video/wii/SDL_wiivideo.c b/src/video/ogc/SDL_ogc_video.c
similarity index 85%
rename from src/video/wii/SDL_wiivideo.c
rename to src/video/ogc/SDL_ogc_video.c
index ec3bc2fd0..e5b968463 100644
--- a/src/video/wii/SDL_wiivideo.c
+++ b/src/video/ogc/SDL_ogc_video.c
@@ -29,34 +29,49 @@
 #include "SDL_timer.h"
 #include "SDL_thread.h"
 
-// SDL Wii specifics.
+// SDL ogc specifics.
 #include <gccore.h>
 #include <ogcsys.h>
 #include <malloc.h>
 #include <wiiuse/wpad.h>
-#include "SDL_wiivideo.h"
-#include "SDL_wiievents_c.h"
+#include "SDL_ogc_video.h"
+
+#ifdef __wii__
+#include "../wii/SDL_wiievents_c.h"
+#endif
+
+#ifdef __gamecube__
+#include "../gamecube/SDL_gamecube_events_c.h"
+#endif
+
+
 #include <ogc/machine/processor.h>
 
-static const char	WIIVID_DRIVER_NAME[] = "wii";
+static const char	OGCVID_DRIVER_NAME[] = "ogc-video";
 static lwp_t videothread = LWP_THREAD_NULL;
 static SDL_mutex *videomutex = NULL;
 static SDL_cond *videocond = NULL;
-static WiiVideo *current = NULL;
+static ogcVideo *current = NULL;
 
 int vresx=0, vresy=0;
 
 /*** SDL ***/
-static SDL_Rect mode_320, mode_640, mode_848;
+static SDL_Rect mode_320, mode_640;
+#ifdef __wii__
+static SDL_Rect mode_848;
+#endif
 
 static SDL_Rect* modes_descending[] =
 {
+#ifdef __wii__
 	&mode_848,
+#endif
 	&mode_640,
 	&mode_320,
 	NULL
 };
 
+
 /*** 2D Video ***/
 #define HASPECT 			320
 #define VASPECT 			240
@@ -271,7 +286,7 @@ StartVideoThread(void *args)
 	}
 }
 
-void WII_VideoStart(WiiVideo *private)
+void OGC_VideoStart(ogcVideo *private)
 {
 	if (private==NULL) {
 		if (current==NULL)
@@ -282,11 +297,13 @@ void WII_VideoStart(WiiVideo *private)
 	SetupGX();
 	draw_init(private->palette, private->texturemem);
 	StartVideoThread(&private->texturemem);
+#ifdef __wii__
 	WPAD_SetVRes(WPAD_CHAN_0, vresx+vresx/4, vresy+vresy/4);
+#endif
 	current = private;
 }
 
-void WII_VideoStop()
+void OGC_VideoStop()
 {
 	if(videothread == LWP_THREAD_NULL)
 		return;
@@ -300,11 +317,13 @@ void WII_VideoStop()
 	videothread = LWP_THREAD_NULL;
 }
 
-static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
+static int OGC_VideoInit(_THIS, SDL_PixelFormat *vformat)
 {
 	// Set up the modes.
+#ifdef __wii__
 	mode_848.w = 848;
 	mode_848.h = 480;
+#endif
 	mode_640.w = 640;
 	mode_640.h = 480;
 	mode_320.w = 320;
@@ -324,12 +343,12 @@ static int WII_VideoInit(_THIS, SDL_PixelFormat *vformat)
 	return 0;
 }
 
-static SDL_Rect **WII_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+static SDL_Rect **OGC_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
 {
 	return modes_descending;
 }
 
-static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
+static SDL_Surface *OGC_SetVideoMode(_THIS, SDL_Surface *current,
 								   int width, int height, int bpp, Uint32 flags)
 {
 	SDL_Rect* 		mode;
@@ -365,7 +384,7 @@ static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
 
 	bytes_per_pixel = bpp / 8;
 
-	WII_VideoStop();
+	OGC_VideoStop();
 
 	free(this->hidden->buffer);
 	free(this->hidden->texturemem);
@@ -431,28 +450,28 @@ static SDL_Surface *WII_SetVideoMode(_THIS, SDL_Surface *current,
 	vresx = currentwidth;
 	vresy = currentheight;
 
-	WII_VideoStart(this->hidden);
+	OGC_VideoStart(this->hidden);
 
 	return current;
 }
 
 /* We don't actually allow hardware surfaces other than the main one */
-static int WII_AllocHWSurface(_THIS, SDL_Surface *surface)
+static int OGC_AllocHWSurface(_THIS, SDL_Surface *surface)
 {
 	return(-1);
 }
 
-static void WII_FreeHWSurface(_THIS, SDL_Surface *surface)
+static void OGC_FreeHWSurface(_THIS, SDL_Surface *surface)
 {
 	return;
 }
 
-static int WII_LockHWSurface(_THIS, SDL_Surface *surface)
+static int OGC_LockHWSurface(_THIS, SDL_Surface *surface)
 {
 	return(0);
 }
 
-static void WII_UnlockHWSurface(_THIS, SDL_Surface *surface)
+static void OGC_UnlockHWSurface(_THIS, SDL_Surface *surface)
 {
 	return;
 }
@@ -595,7 +614,7 @@ static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
 	SDL_mutexV(videomutex);
 }
 
-static void WII_UpdateRect(_THIS, SDL_Rect *rect)
+static void OGC_UpdateRect(_THIS, SDL_Rect *rect)
 {
 	const SDL_Surface* const screen = this->screen;
 
@@ -618,7 +637,7 @@ static void WII_UpdateRect(_THIS, SDL_Rect *rect)
 	}
 }
 
-static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+static void OGC_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
 {
 	int i;
 
@@ -627,7 +646,7 @@ static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
 
 	for (i = 0; i < numrects; i++)
 	{
-		WII_UpdateRect(this, rects+i);
+		OGC_UpdateRect(this, rects+i);
 	}
 
 	SDL_CondSignal(videocond);
@@ -636,16 +655,16 @@ static void WII_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
 static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
 {
 	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	WII_UpdateRects(this, 1, &screen_rect);
+	OGC_UpdateRects(this, 1, &screen_rect);
 }
 
 static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
 {
 	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
-	WII_UpdateRects(this, 1, &screen_rect);
+	OGC_UpdateRects(this, 1, &screen_rect);
 }
 
-static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
+static int OGC_FlipHWSurface(_THIS, SDL_Surface *surface)
 {
 	switch(surface->format->BytesPerPixel)
 	{
@@ -666,7 +685,7 @@ static int WII_FlipHWSurface(_THIS, SDL_Surface *surface)
 	return 0;
 }
 
-static int WII_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
+static int OGC_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
 {
 	const int last_color = first_color + color_count;
 	Uint16* const palette = this->hidden->palette;
@@ -693,9 +712,9 @@ static int WII_SetColors(_THIS, int first_color, int color_count, SDL_Color *col
 	return(1);
 }
 
-static void WII_VideoQuit(_THIS)
+static void OGC_VideoQuit(_THIS)
 {
-	WII_VideoStop();
+	OGC_VideoStop();
 	GX_AbortFrame();
 	GX_Flush();
 
@@ -710,7 +729,7 @@ static void WII_VideoQuit(_THIS)
 	this->hidden->texturemem = NULL;
 }
 
-static void WII_DeleteDevice(SDL_VideoDevice *device)
+static void OGC_DeleteDevice(SDL_VideoDevice *device)
 {
 	free(device->hidden);
 	SDL_free(device);
@@ -721,7 +740,7 @@ static void WII_DeleteDevice(SDL_VideoDevice *device)
 	videomutex=0;
 }
 
-static SDL_VideoDevice *WII_CreateDevice(int devindex)
+static SDL_VideoDevice *OGC_CreateDevice(int devindex)
 {
 	SDL_VideoDevice *device;
 
@@ -745,39 +764,45 @@ static SDL_VideoDevice *WII_CreateDevice(int devindex)
 	videocond = SDL_CreateCond();
 
 	/* Set the function pointers */
-	device->VideoInit = WII_VideoInit;
-	device->ListModes = WII_ListModes;
-	device->SetVideoMode = WII_SetVideoMode;
-	device->SetColors = WII_SetColors;
-	device->UpdateRects = WII_UpdateRects;
-	device->VideoQuit = WII_VideoQuit;
-	device->AllocHWSurface = WII_AllocHWSurface;
-	device->LockHWSurface = WII_LockHWSurface;
-	device->UnlockHWSurface = WII_UnlockHWSurface;
-	device->FlipHWSurface = WII_FlipHWSurface;
-	device->FreeHWSurface = WII_FreeHWSurface;
+	device->VideoInit = OGC_VideoInit;
+	device->ListModes = OGC_ListModes;
+	device->SetVideoMode = OGC_SetVideoMode;
+	device->SetColors = OGC_SetColors;
+	device->UpdateRects = OGC_UpdateRects;
+	device->VideoQuit = OGC_VideoQuit;
+	device->AllocHWSurface = OGC_AllocHWSurface;
+	device->LockHWSurface = OGC_LockHWSurface;
+	device->UnlockHWSurface = OGC_UnlockHWSurface;
+	device->FlipHWSurface = OGC_FlipHWSurface;
+	device->FreeHWSurface = OGC_FreeHWSurface;
+#ifdef __wii__
 	device->InitOSKeymap = WII_InitOSKeymap;
 	device->PumpEvents = WII_PumpEvents;
+#endif
+#ifdef __gamecube__
+	device->InitOSKeymap = GAMECUBE_InitOSKeymap;
+	device->PumpEvents = GAMECUBE_PumpEvents;
+#endif
 	device->input_grab = SDL_GRAB_ON;
 
-	device->free = WII_DeleteDevice;
+	device->free = OGC_DeleteDevice;
 
-	WII_InitVideoSystem();
+	OGC_InitVideoSystem();
 	return device;
 }
 
-static int WII_Available(void)
+static int OGC_Available(void)
 {
 	return(1);
 }
 
-VideoBootStrap WII_bootstrap = {
-	WIIVID_DRIVER_NAME, "Wii video driver",
-	WII_Available, WII_CreateDevice
+VideoBootStrap OGC_bootstrap = {
+	OGCVID_DRIVER_NAME, "ogc video driver",
+	OGC_Available, OGC_CreateDevice
 };
 
 void
-WII_InitVideoSystem()
+OGC_InitVideoSystem()
 {
 	/* Initialise the video system */
 	VIDEO_Init();
@@ -815,7 +840,7 @@ WII_InitVideoSystem()
 	SetupGX();
 }
 
-void WII_SetWidescreen(int wide)
+void OGC_SetWidescreen(int wide)
 {
 	int width;
 	if(wide) {
@@ -837,7 +862,7 @@ void WII_SetWidescreen(int wide)
 	VIDEO_WaitVSync(); VIDEO_WaitVSync();
 }
 
-void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
 {
 	square[6] = square[3]  =  xscale + xshift;
 	square[0] = square[9]  = -xscale + xshift;
diff --git a/src/video/ogc/SDL_ogc_video.h b/src/video/ogc/SDL_ogc_video.h
new file mode 100644
index 000000000..f104034d6
--- /dev/null
+++ b/src/video/ogc/SDL_ogc_video.h
@@ -0,0 +1,37 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_ogc_video_h
+#define _SDL_ogc_video_h
+
+/* SDL internal includes */
+#include "../SDL_sysvideo.h"
+
+/* OGC includes */
+#include <ogc/gx_struct.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_VideoDevice *this
+
+/* Private display data */
+typedef struct SDL_PrivateVideoData
+{
+    // 2x256x16bit palettes = 1x256x24(32)bit palette
+    // first 256 entries are for Red/Green
+    // last 256 entries are for Green
+    Uint16 palette[2*256];
+
+    Uint8* buffer;
+
+    // these two fields MUST be in this order
+    Uint8* texturemem;
+    size_t texturemem_size;
+
+    int    width;
+    int    height;
+    int    pitch;
+} ogcVideo;
+
+void OGC_InitVideoSystem();
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
+
+#endif /* _SDL_wiivideo_h */
diff --git a/src/video/wii/SDL_wiievents.c b/src/video/wii/SDL_wiievents.c
index 720b59532..9a75458f6 100644
--- a/src/video/wii/SDL_wiievents.c
+++ b/src/video/wii/SDL_wiievents.c
@@ -31,7 +31,6 @@
 #include <wiikeyboard/keyboard.h>
 #include <ogc/pad.h>
 
-#include "SDL_wiivideo.h"
 #include "SDL_wiievents_c.h"
 
 static SDLKey keymap[232];
diff --git a/src/video/wii/SDL_wiievents_c.h b/src/video/wii/SDL_wiievents_c.h
index f17f2b884..c75b13d1f 100644
--- a/src/video/wii/SDL_wiievents_c.h
+++ b/src/video/wii/SDL_wiievents_c.h
@@ -21,7 +21,7 @@
 */
 #include "SDL_config.h"
 
-#include "SDL_wiivideo.h"
+#include "../ogc/SDL_ogc_video.h"
 
 /* Variables and functions exported by SDL_sysevents.c to other parts 
    of the native video subsystem (SDL_sysvideo.c)
diff --git a/src/video/wii/SDL_wiimouse_c.h b/src/video/wii/SDL_wiimouse_c.h
index a890d392c..74ac4abc0 100644
--- a/src/video/wii/SDL_wiimouse_c.h
+++ b/src/video/wii/SDL_wiimouse_c.h
@@ -21,6 +21,6 @@
 */
 #include "SDL_config.h"
 
-#include "SDL_wiivideo.h"
+#include "../ogc/SDL_ogc_video.h"
 
 /* Functions to be exported */
diff --git a/src/video/wii/SDL_wiivideo.h b/src/video/wii/SDL_wiivideo.h
deleted file mode 100644
index c0331f076..000000000
--- a/src/video/wii/SDL_wiivideo.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2006 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Tantric, 2009
-*/
-#include "SDL_config.h"
-
-#ifndef _SDL_wiivideo_h
-#define _SDL_wiivideo_h
-
-/* SDL internal includes */
-#include "../SDL_sysvideo.h"
-
-/* OGC includes */
-#include <ogc/gx_struct.h>
-
-/* Hidden "this" pointer for the video functions */
-#define _THIS   SDL_VideoDevice *this
-
-/* Private display data */
-typedef struct SDL_PrivateVideoData
-{
-    // 2x256x16bit palettes = 1x256x24(32)bit palette
-    // first 256 entries are for Red/Green
-    // last 256 entries are for Green
-    Uint16 palette[2*256];
-
-    Uint8* buffer;
-
-    // these two fields MUST be in this order
-    Uint8* texturemem;
-    size_t texturemem_size;
-
-    int    width;
-    int    height;
-    int    pitch;
-} WiiVideo;
-
-void WII_InitVideoSystem();
-void WII_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
-
-#endif /* _SDL_wiivideo_h */
-- 
2.30.2


From a64442b51a1edd4e062b407a299bcb4fc161b9dc Mon Sep 17 00:00:00 2001
From: Dave Murphy <davem@devkitpro.org>
Date: Sun, 21 Jun 2020 14:21:15 +0100
Subject: [PATCH 21/24] clean up SDLmain

---
 src/main/gamecube/SDL_gamecube_main.c |  4 ----
 src/main/wii/SDL_wii_main.c           | 10 +---------
 2 files changed, 1 insertion(+), 13 deletions(-)

diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
index fbbd91334..59288fb44 100644
--- a/src/main/gamecube/SDL_gamecube_main.c
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -18,13 +18,9 @@ int main(int argc, char *argv[])
 {
 //	SYS_SetPowerCallback(ShutdownCB);
 //	SYS_SetResetCallback(ResetCB);
-	printf("PAD Init\n");
 	PAD_Init();
-	printf("video init\n");
 	OGC_InitVideoSystem();
-	printf("fat init\n");
 	fatInitDefault();
 	/* Call the user's main function */
-	printf("call main\n");
 	return(SDL_main(argc, argv));
 }
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
index 741b184a8..7cfc72400 100644
--- a/src/main/wii/SDL_wii_main.c
+++ b/src/main/wii/SDL_wii_main.c
@@ -17,7 +17,6 @@
 
 bool TerminateRequested=false, ShutdownRequested=false, ResetRequested=false;
 
-#ifdef HW_RVL
 void SDL_Quit();
 static void ShutdownCB()
 {
@@ -46,7 +45,6 @@ void Terminate()
 	if (ShutdownRequested) ShutdownWii();
 	else if (ResetRequested) RestartHomebrewChannel();
 }
-#endif
 
 /* Do initialisation which has to be done first for the console to work */
 /* Entry point */
@@ -71,14 +69,8 @@ int main(int argc, char *argv[])
 
 	MOUSE_Init();
 	KEYBOARD_Init(NULL);
-    fatInitDefault();
+	fatInitDefault();
 	/* Call the user's main function */
 	return(SDL_main(argc, argv));
 }
 
-/* This function isn't implemented */
-/*int unlink(const char* file_name)
-{
-	return -1;
-}
-*/
-- 
2.30.2


From d9996575ea8c466332f0f1e2bd41ae3f4f6734a8 Mon Sep 17 00:00:00 2001
From: retro100 <77205307+retro100@users.noreply.github.com>
Date: Mon, 3 May 2021 12:58:19 +0200
Subject: [PATCH 22/24] Bugfix for SDL_GetTicks() with current libogc version.
 (#74)

Co-authored-by: retro100 <retro100@dummy.local>
---
 src/timer/ogc/SDL_systimer.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/timer/ogc/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
index 03fa76445..931b8e8e9 100644
--- a/src/timer/ogc/SDL_systimer.c
+++ b/src/timer/ogc/SDL_systimer.c
@@ -31,13 +31,16 @@
 
 #include <ogcsys.h>
 
+static Uint64 start;
+
 void SDL_StartTicks(void)
 {
+	start = gettime();
 }
 
 Uint32 SDL_GetTicks (void)
 {
-	const Uint64 ticks	= gettime();
+	const Uint64 ticks	= gettime() - start;
 	const Uint64 ms		= ticks / TB_TIMER_CLOCK;
 	return ms;
 }
-- 
2.30.2


From c57f0cdfa598ad690a4e0ec80bd926fb4304006d Mon Sep 17 00:00:00 2001
From: Juan de la Cruz Caravaca Guerrero
 <65747773+Anthypatos@users.noreply.github.com>
Date: Thu, 13 Apr 2023 12:23:12 +0200
Subject: [PATCH 23/24] Fix joystick update (#20)

---
 src/joystick/wii/SDL_sysjoystick.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/joystick/wii/SDL_sysjoystick.c b/src/joystick/wii/SDL_sysjoystick.c
index 8be904496..88aa28ddb 100644
--- a/src/joystick/wii/SDL_sysjoystick.c
+++ b/src/joystick/wii/SDL_sysjoystick.c
@@ -295,7 +295,7 @@ static void _HandleWiiJoystickUpdate(SDL_Joystick* joystick)
 	WPADData *data;
 	const u32 *buttons;
 
-	if (!WPAD_ReadPending(WPAD_CHAN_0, NULL))
+	if (!WPAD_ReadPending(joystick->index, NULL))
 		return;
 	data = WPAD_Data(joystick->index);
 	changed = data->btns_d | data->btns_u;
-- 
2.30.2


From 2352d0056ebff98c45903574f7042776076cf52d Mon Sep 17 00:00:00 2001
From: Juan de la Cruz Caravaca Guerrero <juan.dlcruzcg@gmail.com>
Date: Fri, 13 Oct 2023 00:07:02 +0200
Subject: [PATCH 24/24] lower thread priority

---
 src/thread/ogc/SDL_systhread.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/thread/ogc/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
index e720e91ac..f45bf5393 100644
--- a/src/thread/ogc/SDL_systhread.c
+++ b/src/thread/ogc/SDL_systhread.c
@@ -49,7 +49,7 @@ void *run_thread(void *data)
 int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
 {
 	
-	if ( LWP_CreateThread(&thread->handle, run_thread, args, 0, 0, 64) != 0 ) {
+	if ( LWP_CreateThread(&thread->handle, run_thread, args, 0, 0, 16) != 0 ) {
 		SDL_SetError("Not enough resources to create thread");
 		return(-1);
 	}
-- 
2.30.2

